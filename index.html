<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>KIPP – Schritt 1 (Canvas, W1 gespiegelt)</title>

  <style>
    :root{
      --violett: rgb(164, 27, 133);
      --blau:    rgb(0, 107, 179);
      --gruen:   rgb(0, 166, 82);
      --orange:  rgb(249, 150, 30);

      --cell-gap: clamp(5px, 1.1vmin, 10px);
      --cell-radius: clamp(6px, 1.1vmin, 12px);

      --floor: #7a4a34;

      --board-border: 4px;
      --board-border-color: #000;
      --board-radius: clamp(14px, 2.2vmin, 22px);
    }

    html, body { height: 100%; }
    body{
      margin:0;
      display:flex;
      justify-content:center;
      background:
        radial-gradient(ellipse at center, rgba(0,0,0,0.00) 40%, rgba(0,0,0,0.38) 100%),
        linear-gradient(180deg, rgba(0,0,0,0.20), rgba(0,0,0,0.00) 18%, rgba(0,0,0,0.00) 82%, rgba(0,0,0,0.22)),
        repeating-linear-gradient(
          90deg,
          rgba(0,0,0,0.10) 0px,
          rgba(0,0,0,0.10) 2px,
          rgba(255,255,255,0.04) 2px,
          rgba(255,255,255,0.04) 56px
        ),
        repeating-linear-gradient(
          12deg,
          rgba(0,0,0,0.05) 0px,
          rgba(0,0,0,0.05) 8px,
          rgba(255,255,255,0.03) 8px,
          rgba(255,255,255,0.03) 16px
        ),
        linear-gradient(180deg, #e0b47c, #c89259);
      background-attachment: fixed;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .stage{
      width: min(94vw, 680px);
      margin-top: 14vh;
      display:flex;
      flex-direction: column;
      align-items:center;
      gap: 14px;
    }

    .board{
      position:relative;
      width: 100%;
      height: 0;
      aspect-ratio: 1 / 1;
      box-sizing: border-box;

      background: #0b0b0b;
      border: var(--board-border) solid var(--board-border-color);
      border-radius: var(--board-radius);

      overflow: visible;

      /* Zellmaß als Variable */
      --cell: calc((100% - 7 * var(--cell-gap)) / 8);
      --step: calc(var(--cell) + var(--cell-gap));

      box-shadow:
        10px 18px 42px rgba(0,0,0,0.55),
        3px 6px 16px rgba(0,0,0,0.35);
    }

    .grid{
      position:absolute;
      inset:0;
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      gap: var(--cell-gap);
      pointer-events: none;
      z-index: 1;
    }

    .cell{
      background:#0b0b0b;
      border-radius: var(--cell-radius);
      box-shadow:
        0 0 0 1px rgba(255,255,255,0.035) inset,
        0 10px 18px rgba(0,0,0,0.32);
    }

    .c-orange{ background: var(--orange); }
    .c-gruen { background: var(--gruen);  }
    .c-violett{ background: var(--violett); }
    .c-blau  { background: var(--blau);   }

    .floor{
      position:absolute;
      left: var(--step);
      top:  var(--step);
      width: calc(6 * var(--cell) + 5 * var(--cell-gap));
      height: calc(6 * var(--cell) + 5 * var(--cell-gap));
      background:
        linear-gradient(135deg, rgba(255,255,255,0.18), rgba(0,0,0,0.06)),
        var(--floor);
      z-index: 2;
      pointer-events: none;

      box-shadow:
        inset 14px 14px 26px rgba(255,255,255,0.14),
        inset -18px -18px 34px rgba(0,0,0,0.22),
        inset 0 0 0 1px rgba(0,0,0,0.12),
        inset -22px 0 34px rgba(0,0,0,0.30),
        inset  22px 0 34px rgba(0,0,0,0.30),
        inset  0 -22px 34px rgba(0,0,0,0.34),
        inset  0  22px 34px rgba(0,0,0,0.34);
    }

    .ball{
      position:absolute;
      left: calc(var(--step) + ( (6 * var(--cell) + 5 * var(--cell-gap)) / 2 ));
      top:  calc(var(--step) + ( (6 * var(--cell) + 5 * var(--cell-gap)) / 2 ));
      width: calc(var(--cell) * 0.55);
      height: calc(var(--cell) * 0.55);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      background:
        radial-gradient(circle at 30% 28%, rgba(255,255,255,0.55), rgba(255,255,255,0.0) 45%),
        radial-gradient(circle at 55% 60%, rgba(0,0,0,0.18), rgba(0,0,0,0.00) 55%),
        radial-gradient(circle at 50% 55%, #d6b996, #b88d63 70%);
      box-shadow: 0 3px 6px rgba(0,0,0,0.28);
      z-index: 4;
      pointer-events: none;
    }

    /* Canvas liegt über Boden & Grid */
    canvas#w1Canvas{
      position:absolute;
      inset:0;
      z-index: 5;
      pointer-events:none;
    }
  </style>
</head>

<body>
  <div class="stage">
    <div class="board" id="board">
      <div class="floor" aria-hidden="true"></div>
      <div class="ball" aria-label="Kugel"></div>

      <div id="grid" class="grid" aria-label="8×8 Raster"></div>

      <!-- ✅ W1 wird sauber per Canvas gerendert -->
      <canvas id="w1Canvas"></canvas>
    </div>
  </div>

  <script>
    // ====== Einstellungen ======
    const MIRROR_W1 = true; // true = W1 in sich links↔rechts gespiegelt (um eigene senkrechte Mittelachse)

    const boardEl  = document.getElementById("board");
    const gridEl   = document.getElementById("grid");
    const canvas   = document.getElementById("w1Canvas");
    const ctx      = canvas.getContext("2d");

    // ----- Board-Farbzellen -----
    const cols = ["A","B","C","D","E","F","G","H"];
    function key(r, cLetter){ return `${r}${cLetter}`; }

    const colorMap = new Map([
      [key(3,"A"), "c-orange"],
      [key(4,"A"), "c-gruen"],
      [key(5,"A"), "c-violett"],
      [key(6,"A"), "c-blau"],

      [key(8,"C"), "c-gruen"],
      [key(8,"D"), "c-orange"],
      [key(8,"E"), "c-gruen"],
      [key(8,"F"), "c-orange"],

      [key(6,"H"), "c-violett"],
      [key(5,"H"), "c-blau"],
      [key(4,"H"), "c-orange"],
      [key(3,"H"), "c-gruen"],

      [key(1,"F"), "c-blau"],
      [key(1,"E"), "c-violett"],
      [key(1,"D"), "c-blau"],
      [key(1,"C"), "c-violett"],
    ]);

    function buildGridOnce(){
      if (gridEl.dataset.built === "1") return;
      for(let r=1; r<=8; r++){
        for(let c=0; c<8; c++){
          const cell = document.createElement("div");
          cell.className = "cell";
          const coord = key(r, cols[c]);
          if(colorMap.has(coord)) cell.classList.add(colorMap.get(coord));
          gridEl.appendChild(cell);
        }
      }
      gridEl.dataset.built = "1";
    }

    // ----- Helpers für CSS-Variablen in Pixel -----
    function getPxVar(name){
      const v = getComputedStyle(boardEl).getPropertyValue(name).trim();
      return parseFloat(v) || 0;
    }

    function resizeCanvasToBoard(){
      const rect = boardEl.getBoundingClientRect();
      const dpr  = window.devicePixelRatio || 1;

      canvas.width  = Math.round(rect.width  * dpr);
      canvas.height = Math.round(rect.height * dpr);
      canvas.style.width  = rect.width + "px";
      canvas.style.height = rect.height + "px";

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // in CSS-Pixeln zeichnen
      ctx.clearRect(0, 0, rect.width, rect.height);
    }

    // ====== W1 Zeichnen (Canvas) ======
    function drawRoundedRect(x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y,   x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x,   y+h, rr);
      ctx.arcTo(x,   y+h, x,   y,   rr);
      ctx.arcTo(x,   y,   x+w, y,   rr);
      ctx.closePath();
    }

    function drawW1(){
      const rect = boardEl.getBoundingClientRect();
      const cell = getPxVar("--cell");
      const gap  = getPxVar("--cell-gap");
      const step = getPxVar("--step");

      // Q0 Position wie bei dir: cube-col=1, cube-row=1
      const cubeCol = 1;
      const cubeRow = 1;
      const cubeX = cubeCol * step;
      const cubeY = cubeRow * step;

      const cubeSize = 3 * cell + 2 * gap;
      const radius   = Math.min(18, Math.max(10, cubeSize * 0.08)); // optisch ähnlich
      const borderW  = 4;

      // Slot Maße (wie vorher)
      const slotSize = cell;
      const slotR    = Math.min(12, Math.max(6, slotSize * 0.22));
      const slotBorderW = 2;

      // Slot-Positionen relativ in Q0 (wie zuvor)
      const slots = [
        // oben Reihe (2c,2d)
        { x: cubeX + 1*step, y: cubeY + 0*step },
        { x: cubeX + 2*step, y: cubeY + 0*step },
        // links Spalte (3b,4b)
        { x: cubeX + 0*step, y: cubeY + 1*step },
        { x: cubeX + 0*step, y: cubeY + 2*step },
      ];

      // Spiegelung um eigene senkrechte Mittelachse von W1:
      // -> Canvas: um cx/cy von W1 spiegeln (scale(-1,1))
      const cx = cubeX + cubeSize/2;
      const cy = cubeY + cubeSize/2;

      ctx.save();
      if (MIRROR_W1){
        ctx.translate(cx, cy);
        ctx.scale(-1, 1);
        ctx.translate(-cx, -cy);
      }

      // Schatten unter W1 (leicht)
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.28)";
      ctx.shadowBlur  = 18;
      ctx.shadowOffsetX = 12;
      ctx.shadowOffsetY = 12;
      ctx.fillStyle = "rgba(0,0,0,0.01)"; // nur Schatten "tragen"
      drawRoundedRect(cubeX, cubeY, cubeSize, cubeSize, radius);
      ctx.fill();
      ctx.restore();

      // Würfelfläche (Holz-Look via Gradients)
      // Grundverlauf
      const g = ctx.createLinearGradient(cubeX, cubeY, cubeX+cubeSize, cubeY+cubeSize);
      g.addColorStop(0.00, "rgba(255,255,255,0.16)");
      g.addColorStop(1.00, "rgba(0,0,0,0.08)");

      const wood = ctx.createLinearGradient(cubeX, cubeY, cubeX, cubeY+cubeSize);
      wood.addColorStop(0.00, "#d7c2a4");
      wood.addColorStop(1.00, "#c9b08f");

      // Füllung (wood + overlay)
      drawRoundedRect(cubeX, cubeY, cubeSize, cubeSize, radius);
      ctx.fillStyle = wood;
      ctx.fill();

      ctx.globalAlpha = 1.0;
      ctx.fillStyle = g;
      ctx.fill();

      // leichte "Wärme/Gelb" Spots (wie dein CSS)
      const spot1 = ctx.createRadialGradient(
        cubeX + cubeSize*0.15, cubeY + cubeSize*0.15, 0,
        cubeX + cubeSize*0.15, cubeY + cubeSize*0.15, cubeSize*0.9
      );
      spot1.addColorStop(0.0, "rgba(249,150,30,0.10)");
      spot1.addColorStop(0.55, "rgba(249,150,30,0.00)");
      ctx.fillStyle = spot1;
      ctx.fill();

      const spot2 = ctx.createRadialGradient(
        cubeX + cubeSize*0.25, cubeY + cubeSize*0.25, 0,
        cubeX + cubeSize*0.25, cubeY + cubeSize*0.25, cubeSize*0.95
      );
      spot2.addColorStop(0.0, "rgba(155,70,110,0.10)");
      spot2.addColorStop(0.60, "rgba(155,70,110,0.00)");
      ctx.fillStyle = spot2;
      ctx.fill();

      // Border
      ctx.lineWidth = borderW;
      ctx.strokeStyle = "#7a4a34";
      drawRoundedRect(cubeX, cubeY, cubeSize, cubeSize, radius);
      ctx.stroke();

      // Innen-Highlight
      ctx.lineWidth = 1;
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      drawRoundedRect(cubeX + borderW*0.5, cubeY + borderW*0.5, cubeSize - borderW, cubeSize - borderW, radius-1);
      ctx.stroke();

      // Slots (leer)
      for (const s of slots){
        // Slot Schatten
        ctx.save();
        ctx.shadowColor = "rgba(0,0,0,0.22)";
        ctx.shadowBlur  = 10;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 3;

        drawRoundedRect(s.x, s.y, slotSize, slotSize, slotR);
        ctx.fillStyle = "#ead7be";
        ctx.fill();
        ctx.restore();

        // Slot "Lichtkante"
        const sg = ctx.createLinearGradient(s.x, s.y, s.x+slotSize, s.y+slotSize);
        sg.addColorStop(0.0, "rgba(255,255,255,0.14)");
        sg.addColorStop(1.0, "rgba(0,0,0,0.05)");
        drawRoundedRect(s.x, s.y, slotSize, slotSize, slotR);
        ctx.fillStyle = sg;
        ctx.fill();

        // Slot Border
        ctx.lineWidth = slotBorderW;
        ctx.strokeStyle = "rgba(0,0,0,0.55)";
        drawRoundedRect(s.x, s.y, slotSize, slotSize, slotR);
        ctx.stroke();

        // Slot Innenkanten
        ctx.lineWidth = 1;
        ctx.strokeStyle = "rgba(255,255,255,0.18)";
        drawRoundedRect(s.x+1, s.y+1, slotSize-2, slotSize-2, Math.max(2, slotR-1));
        ctx.stroke();
      }

      ctx.restore(); // Spiegel-Transform zurück
    }

    function render(){
      resizeCanvasToBoard();
      drawW1();
    }

    // Init
    window.addEventListener("load", () => {
      buildGridOnce();
      render();
      setTimeout(render, 80);
      requestAnimationFrame(render);
    });

    window.addEventListener("resize", () => {
      render();
      requestAnimationFrame(render);
    });
  </script>
</body>
</html>
