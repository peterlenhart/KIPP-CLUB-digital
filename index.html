<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KIPP – 8×8 Raster</title>
  <style>
    :root{
      /* Deine Farben */
      --violett: rgb(164, 27, 133);
      --blau:    rgb(0, 107, 179);
      --gruen:   rgb(0, 166, 82);
      --gelb:    rgb(249, 150, 30);

      /* Optik */
      --black:   #161616;
      --gridline:#1f1f1f;

      --inner-bg:#E7D5BC;      /* hellbeige Fläche */
      --beige-3x3:#E2C9AD;     /* 2B–4D */
      --brown:   #5B3A29;

      --g: 3px;                /* Raster-Linien (Gap) */
      --color-inset: 4px;      /* schwarzer Rand innerhalb Farbflächen */
    }

    html, body { height: 100%; }
    body{
      margin:0;
      background: radial-gradient(1200px 800px at 50% 10%, #3a251b 0%, #1b120e 60%, #120b08 100%);
      display:flex;
      justify-content:center;
      align-items:flex-start;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    /* Platzierung: über der Mitte */
    .stage{
      width: 100%;
      display:flex;
      justify-content:center;
      padding-top: 10vh;
      padding-bottom: 6vh;
    }

    .board{
      width: min(94vw, 680px);
      aspect-ratio: 1 / 1;
      background: var(--gridline);
      padding: var(--g);
      border-radius: 14px;
      box-shadow: 0 18px 45px rgba(0,0,0,.35);
      position: relative;

      display:grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      gap: var(--g);

      /* Zellgröße für Overlays berechenbar */
      --cell: calc((100% - (7 * var(--g))) / 8);
      user-select:none;
      touch-action: manipulation;
    }

    .cell{
      background: var(--inner-bg);
      border-radius: 6px;
      position: relative;
    }

    /* Außenrand schwarz */
    .cell.border{ background: var(--black); }

    /* 2B–4D leicht anderes Beige */
    .cell.beige3{ background: var(--beige-3x3); }

    /* Farbflächen am Rand mit schwarzem Innenrand */
    .cell.colored{
      box-shadow: inset 0 0 0 var(--color-inset) var(--black);
    }

    /* 4px Dunkelbraun-Rahmen um 2B–4D */
    .bt { box-shadow: inset 0 4px 0 0 var(--brown); }
    .bb { box-shadow: inset 0 -4px 0 0 var(--brown); }
    .bl { box-shadow: inset 4px 0 0 0 var(--brown); }
    .br { box-shadow: inset -4px 0 0 0 var(--brown); }

    .cell.colored.bt{ box-shadow: inset 0 0 0 var(--color-inset) var(--black), inset 0 4px 0 0 var(--brown); }
    .cell.colored.bb{ box-shadow: inset 0 0 0 var(--color-inset) var(--black), inset 0 -4px 0 0 var(--brown); }
    .cell.colored.bl{ box-shadow: inset 0 0 0 var(--color-inset) var(--black), inset 4px 0 0 0 var(--brown); }
    .cell.colored.br{ box-shadow: inset 0 0 0 var(--color-inset) var(--black), inset -4px 0 0 0 var(--brown); }

    /* 2px Rahmen um 4B, 3B, 2C, 2D */
    .cell.fine{ box-shadow: inset 0 0 0 2px var(--brown); }
    .cell.beige3.fine{ box-shadow: inset 0 0 0 2px var(--brown); }

    /* Diese Zellen werden “unsichtbar”, weil ein Overlay darüber die Fläche vollflächig macht */
    .cell.merged{
      background: transparent !important;
      box-shadow: none !important;
      border-radius: 0 !important;
    }

    /* Overlays: vollflächige Bereiche ohne Unterteilungen */
    .overlay{
      position:absolute;
      z-index: 5;
      pointer-events:none;
      border-radius: 10px;
    }

    /* Helper: Rechnet Grid-Positionen (1..8) in px um */
    /* left = padding(g) + (colIndex-1)*(cell+g)  */
    /* top  = padding(g) + (rowIndex-1)*(cell+g)  */
    /* width = cols*cell + (cols-1)*g */
    /* height= rows*cell + (rows-1)*g */
  </style>
</head>
<body>
  <div class="stage">
    <div id="board" class="board" aria-label="8x8 Raster"></div>
  </div>

  <script>
    const board = document.getElementById("board");

    const cols = ["A","B","C","D","E","F","G","H"];
    const rows = [1,2,3,4,5,6,7,8];

    const colIndex = c => cols.indexOf(c) + 1; // 1..8

    // Farbzuordnung aus deiner Liste (Achtung: "gelb" = dein Orange)
    const colored = new Map([
      ["3A","gelb"], ["4A","gruen"], ["5A","violett"], ["6A","blau"],
      ["8C","gruen"], ["8D","gelb"], ["8E","gruen"], ["8F","gelb"],
      ["6H","violett"], ["5H","blau"], ["4H","gelb"], ["3H","gruen"],
      ["1F","blau"], ["1E","violett"], ["1D","blau"], ["1C","violett"],
    ]);

    function colorToCss(name){
      switch(name){
        case "violett": return "var(--violett)";
        case "blau":    return "var(--blau)";
        case "gruen":   return "var(--gruen)";
        case "gelb":    return "var(--gelb)";
        default:        return "var(--inner-bg)";
      }
    }

    function isBorder(r, c){
      return r === 1 || r === 8 || c === "A" || c === "H";
    }

    function isBeige3(r, c){
      return (r >= 2 && r <= 4) && (c >= "B" && c <= "D");
    }

    function brownFrameClasses(r, c){
      const cls = [];
      if(!isBeige3(r, c)) return cls;
      if(r === 2) cls.push("bt");
      if(r === 4) cls.push("bb");
      if(c === "B") cls.push("bl");
      if(c === "D") cls.push("br");
      return cls;
    }

    const fineSet = new Set(["4B","3B","2C","2D"]);

    // Bereiche, die vollflächig sein müssen (Zellen darunter -> class "merged")
    // 1) 3C–4D (2×2)
    function inBlock_3C_4D(r,c){
      return (r >= 3 && r <= 4) && (c >= "C" && c <= "D");
    }
    // 2) 2E–4G (3×3)
    function inBlock_2E_4G(r,c){
      return (r >= 2 && r <= 4) && (c >= "E" && c <= "G");
    }
    // 3) 5B–7G (3×6)
    function inBlock_5B_7G(r,c){
      return (r >= 5 && r <= 7) && (c >= "B" && c <= "G");
    }

    // Grid bauen
    for(const r of rows){
      for(const c of cols){
        const key = `${r}${c}`;
        const cell = document.createElement("div");
        cell.className = "cell";
        cell.dataset.coord = key;

        if(isBorder(r, c)) cell.classList.add("border");
        if(!isBorder(r, c) && isBeige3(r, c)) cell.classList.add("beige3");

        if(colored.has(key)){
          cell.classList.add("colored");
          cell.style.background = colorToCss(colored.get(key));
        }

        for(const cl of brownFrameClasses(r, c)) cell.classList.add(cl);
        if(fineSet.has(key)) cell.classList.add("fine");

        // Zellen, die zu “vollflächigen” Bereichen gehören, transparent schalten:
        if(inBlock_3C_4D(r,c) || inBlock_2E_4G(r,c) || inBlock_5B_7G(r,c)){
          // NICHT den Außenrand anfassen
          if(!isBorder(r,c)) cell.classList.add("merged");
        }

        board.appendChild(cell);
      }
    }

    // Overlays hinzufügen (decken die Gap-Linien ab => Fläche wirkt “ein Stück”)
    function addOverlay(rowStart, colStart, rowCount, colCount, bgCss){
      const ov = document.createElement("div");
      ov.className = "overlay";
      ov.style.background = bgCss;

      const g = "var(--g)";
      const cell = "var(--cell)";

      const leftExpr = `calc(${g} + (${colStart-1}) * (${cell} + ${g}))`;
      const topExpr  = `calc(${g} + (${rowStart-1}) * (${cell} + ${g}))`;
      const widthExpr  = `calc(${colCount} * ${cell} + (${colCount-1}) * ${g})`;
      const heightExpr = `calc(${rowCount} * ${cell} + (${rowCount-1}) * ${g})`;

      ov.style.left = leftExpr;
      ov.style.top = topExpr;
      ov.style.width = widthExpr;
      ov.style.height = heightExpr;

      board.appendChild(ov);
    }

    // 3C–4D (2×2) -> hellbeige (wie Q-Flächen)
    addOverlay(3, colIndex("C"), 2, 2, "var(--inner-bg)");

    // 2E–4G (3×3) -> hellbeige (Q1/Q2 Bereich)
    addOverlay(2, colIndex("E"), 3, 3, "var(--inner-bg)");

    // 5B–7G (3×6) -> hellbeige (Q3/Q2 Bereich groß)
    addOverlay(5, colIndex("B"), 3, 6, "var(--inner-bg)");
  </script>
</body>
</html>
