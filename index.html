<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DigiKipp – Raster mit 01/02 + Board 1–8</title>

  <style>
    :root{
      --violett: rgb(164, 27, 133);
      --blau:    rgb(0, 107, 179);
      --gruen:   rgb(0, 166, 82);
      --orange:  rgb(249, 150, 30);

      /* Typo-Farben bleiben wie gehabt */
      --ui-text: #ead7be;
      --btn-bg:  #ead7be;
      --btn-text:#2a160c;
      --btn-border: rgba(0,0,0,0.35);

      /* ✅ wird per JS gesetzt: Breite/8 */
      --cellpx: 60px;

      /* Würfel */
      --cube-wood-base: #d7c2a4;
      --cube-wood-deep: #c9b08f;
      --cube-wood-warm: rgba(155, 70, 110, 0.10);
      --cube-wood-gold: rgba(249, 150, 30, 0.10);
      --w1-innerframe: rgba(122, 74, 52, 1);

      --slot-border: rgba(0,0,0,0.55);
      --slot-border-w: 2px;
      --slot-fill: #ead7be;

      /* Rotation */
      --rotSign: 1;
      --rot: 0deg;
    }

    html, body { height: 100%; }

    body{
      margin:0;
      display:flex;
      justify-content:center;
      background: #000; /* nur als "Außenrand" – dein PNG liegt innen komplett */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    /* ✅ Stage bleibt, aber OHNE Hintergrund/Panel */
    .stage{
      width: min(94vw, 688px);
      min-height: 100vh;
      position: relative;
      padding: 0;
      margin: 0;
      background: transparent;
      box-sizing: border-box;
      overflow: visible;
    }

    /* ✅ Gesamtraster: 8 Spalten, viele Zeilen (01,02,1..8 + UI-Zeilen) */
    .layout{
      position: relative;
      width: 100%;
      display: grid;
      grid-template-columns: repeat(8, var(--cellpx));
      /* 2 Header-Zeilen + 8 Board-Zeilen + 10 UI-Zeilen (bei Bedarf später mehr) */
      grid-template-rows:
        repeat(2, var(--cellpx))
        repeat(8, var(--cellpx))
        repeat(10, var(--cellpx));
      justify-content: center; /* zentriert im Stage */
      align-content: start;
      gap: 0;
    }

    /* ✅ Unterste Ebene: dein PNG, oben links bei 01A verankert */
    .bgPNG{
      position:absolute;
      left: 0;
      top: 0;
      width: calc(8 * var(--cellpx));
      height: calc((2 + 8 + 10) * var(--cellpx)); /* exakt Rasterhöhe */
      background-image: url("Box_m_Hgr.png");
      background-repeat: no-repeat;
      background-position: left top; /* ✅ 01A */
      background-size: 100% 100%;   /* ✅ füllt das Raster (nicht 50%) */
      z-index: 0;
      pointer-events:none;
    }

    /* ========= HEADER (Zeile 01–02) ========= */
    .navBtn{
      width: calc(var(--cellpx) * 0.75);
      height: calc(var(--cellpx) * 0.75);
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
      background: transparent;
      border: 2px solid var(--ui-text);
      padding:0;
      box-sizing: border-box;
    }
    .navBtn svg{
      width: calc(var(--cellpx) * 0.45);
      height: calc(var(--cellpx) * 0.45);
      stroke: var(--ui-text);
      stroke-width: 5;
      fill: none;
      stroke-linecap: square;
      stroke-linejoin: miter;
    }
    .navBtn:active{ transform: scale(0.98); filter: brightness(1.03); }

    .headerBack{
      grid-column: 1 / span 1;
      grid-row: 1 / span 2; /* zwischen Zeile 01 und 02 */
      justify-self: start;
      align-self: center;
      margin-left: 8px; /* ✅ 8px rein */
      z-index: 10;
    }
    .headerExit{
      grid-column: 8 / span 1;
      grid-row: 1 / span 2;
      justify-self: end;
      align-self: center;
      margin-right: 8px; /* ✅ 8px rein */
      z-index: 10;
    }
    .headerTitle{
      grid-column: 2 / span 6;
      grid-row: 1 / span 2;
      align-self: center;
      justify-self: center;
      z-index: 10;
      color: var(--ui-text);
      font-weight: 1000;
      letter-spacing: 0.08em;
      font-size: clamp(22px, 6.0vmin, 44px);
      line-height: 1;
      white-space: nowrap;
      text-shadow: 0 1px 0 rgba(0,0,0,0.28), 0 10px 18px rgba(0,0,0,0.18);
    }

    /* ========= BOARD (Zeile 1–8) ========= */
    .board{
      grid-column: 1 / span 8;
      grid-row: 3 / span 8; /* ✅ Board ist Zeile 1–8, aber im Gesamtraster nach 01/02 */
      position: relative;
      width: calc(8 * var(--cellpx));
      height: calc(8 * var(--cellpx));
      z-index: 5;
      overflow: visible;
    }

    .grid{
      position:absolute;
      inset:0;
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      gap: 0;
      pointer-events: none;
      z-index: 1;
    }

    .cell{
      background: transparent; /* ✅ kein Schwarz */
      box-sizing: border-box;
      position: relative;
    }

    .c-orange{ background: var(--orange); }
    .c-gruen { background: var(--gruen);  }
    .c-violett{ background: var(--violett); }
    .c-blau  { background: var(--blau);   }

    /* ✅ KEIN schwarzer Rahmen mehr */
    .cell.colorCell{
      box-shadow: none;
    }

    /* ===== Target Zahl ===== */
    @keyframes targetBreath{
      0%,100%{ transform: translate(-50%, -50%) rotate(var(--trot, 0deg)) scale(1); opacity: 0.95; }
      50%    { transform: translate(-50%, -50%) rotate(var(--trot, 0deg)) scale(1.10); opacity: 1; }
    }
    .targetBadge{
      position:absolute;
      left:50%;
      top:50%;
      font-weight: 900;
      font-size: clamp(18px, 8vmin, 36px);
      color: rgba(0,0,0,0.92);
      text-shadow: 0 1px 0 rgba(255,255,255,0.35);
      line-height: 1;
      letter-spacing: 0.01em;
      pointer-events:none;
      z-index: 3;
      animation: targetBreath 1.25s ease-in-out infinite;
      transform-origin: 50% 50%;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .trot-top    { --trot: 0deg; }
    .trot-bottom { --trot: 180deg; }
    .trot-left   { --trot: -90deg; }
    .trot-right  { --trot: 90deg; }

    /* ===== Kugel (bleibt) ===== */
    .ball{
      position:absolute;
      left: 50%;
      top: 50%;
      width: calc(var(--cellpx) * 0.55);
      height: calc(var(--cellpx) * 0.55);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      background:
        radial-gradient(circle at 30% 28%, rgba(255,255,255,0.55), rgba(255,255,255,0.0) 45%),
        radial-gradient(circle at 55% 60%, rgba(0,0,0,0.18), rgba(0,0,0,0.00) 55%),
        radial-gradient(circle at 50% 55%, #d6b996, #b88d63 70%);
      box-shadow: 0 3px 6px rgba(0,0,0,0.28);
      z-index: 3;
      pointer-events: none;
    }

    /* ===== Würfel-Gruppen ===== */
    .wFaceGroup,
    .kipGroup{
      position:absolute;
      inset:0;
      z-index: 4;
      pointer-events:none;

      --cell: var(--cellpx);
      --step: var(--cellpx);

      --pivot-x: calc(4 * var(--step));
      --pivot-y: calc(4 * var(--step));

      transform:
        translate(var(--pivot-x), var(--pivot-y))
        rotate(var(--rot))
        translate(calc(-1 * var(--pivot-x)), calc(-1 * var(--pivot-y)));
      transform-origin: 0 0;
    }

    .hidden{ display:none !important; }

    .cubeShadow{
      position:absolute;
      left: calc(1 * var(--cellpx));
      top:  calc(1 * var(--cellpx));
      width: calc(3 * var(--cellpx));
      height: calc(3 * var(--cellpx));
      z-index: 1;
      background: transparent;
      box-shadow:
        0 22px 26px rgba(0,0,0,0.32),
        0 10px 16px rgba(0,0,0,0.18);
    }

    .cubeFace{
      position:absolute;
      width: calc(3 * var(--cellpx));
      height: calc(3 * var(--cellpx));
      box-sizing: border-box;
      border-radius: 0;
      background:
        radial-gradient(120% 90% at 15% 15%, var(--cube-wood-gold), transparent 55%),
        radial-gradient(120% 90% at 25% 25%, var(--cube-wood-warm), transparent 60%),
        repeating-linear-gradient(
          20deg,
          rgba(0,0,0,0.02) 0px,
          rgba(0,0,0,0.02) 10px,
          rgba(255,255,255,0.02) 10px,
          rgba(255,255,255,0.02) 18px
        ),
        linear-gradient(135deg, rgba(255,255,255,0.16), rgba(0,0,0,0.08)),
        linear-gradient(180deg, var(--cube-wood-base), var(--cube-wood-deep));
      box-shadow:
        inset 0 0 0 2px var(--w1-innerframe),
        0 0 0 1px rgba(255,255,255,0.08) inset;
      z-index: 2;
      left: calc(1 * var(--cellpx));
      top:  calc(1 * var(--cellpx));
    }

    .slot{
      position:absolute;
      width: var(--cellpx);
      height: var(--cellpx);
      box-sizing: border-box;
      background:
        linear-gradient(135deg, rgba(255,255,255,0.14), rgba(0,0,0,0.05)),
        var(--slot-fill);
      border: var(--slot-border-w) solid var(--slot-border);
      border-radius: 0;
      z-index: 7;
      box-shadow:
        1px 1px 0 rgba(255,255,255,0.18) inset,
        -1px -1px 0 rgba(0,0,0,0.08) inset,
        0 3px 5px rgba(0,0,0,0.22),
        2px 2px 3px -1px rgba(0,0,0,0.20);
    }

    .slot .num{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      z-index: 9;
    }

    .slot .num > span{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-weight: 900;
      color: #111;
      font-size: clamp(18px, 8vmin, 36px);
      text-shadow: 0 1px 0 rgba(255,255,255,0.35);
      transform: rotate(var(--num-rot, 0deg));
      transform-origin: 50% 50%;
      position: relative;
      line-height: 1;
    }

    .read-south { --num-rot: calc(var(--rotSign) * 0deg); }
    .read-west  { --num-rot: calc(var(--rotSign) * 90deg); }
    .read-east  { --num-rot: calc(var(--rotSign) * -90deg); }
    .read-north { --num-rot: calc(var(--rotSign) * 180deg); }

    /* Slots W (wie gehabt, aber auf cellpx Basis) */
    .s-3b{ left: calc(1 * var(--cellpx)); top: calc(2 * var(--cellpx)); }
    .s-4b{ left: calc(1 * var(--cellpx)); top: calc(3 * var(--cellpx)); }
    .s-2c{ left: calc(2 * var(--cellpx)); top: calc(1 * var(--cellpx)); }
    .s-2d{ left: calc(3 * var(--cellpx)); top: calc(1 * var(--cellpx)); }

    /* Kipp-Ansicht */
    .kipScale{
      position:absolute;
      inset:0;
      transform:
        translate(calc(4 * var(--cellpx)), calc(4 * var(--cellpx)))
        scaleX(0.6666667)
        translate(calc(-4 * var(--cellpx)), calc(-4 * var(--cellpx)));
      transform-origin: 0 0;
    }

    .kipShadow{
      position:absolute;
      left: calc(1 * var(--cellpx));
      top:  calc(1 * var(--cellpx));
      width: calc(6 * var(--cellpx));
      height: calc(3 * var(--cellpx));
      background: transparent;
      z-index: 1;
      box-shadow:
        0 22px 26px rgba(0,0,0,0.32),
        0 10px 16px rgba(0,0,0,0.18);
    }

    .kipEdgeCore{
      position:absolute;
      left: calc(4 * var(--cellpx));
      top:  calc(1 * var(--cellpx));
      width: 6px;
      height: calc(3 * var(--cellpx));
      transform: translateX(-50%);
      background: linear-gradient(90deg, rgba(0,0,0,0.00), rgba(0,0,0,0.28), rgba(0,0,0,0.00));
      z-index: 1;
      opacity: 0.95;
    }

    .kipFaceQ0{ left: calc(1 * var(--cellpx)); top: calc(1 * var(--cellpx)); }
    .kipFaceQ1{ left: calc(4 * var(--cellpx)); top: calc(1 * var(--cellpx)); }

    .k-4d{ left: calc(3 * var(--cellpx)); top: calc(3 * var(--cellpx)); }
    .k-3d{ left: calc(3 * var(--cellpx)); top: calc(2 * var(--cellpx)); }
    .k-2b{ left: calc(1 * var(--cellpx)); top: calc(1 * var(--cellpx)); }
    .k-2c{ left: calc(2 * var(--cellpx)); top: calc(1 * var(--cellpx)); }

    .k-3e{ left: calc(4 * var(--cellpx)); top: calc(2 * var(--cellpx)); }
    .k-4e{ left: calc(4 * var(--cellpx)); top: calc(3 * var(--cellpx)); }
    .k-2f{ left: calc(5 * var(--cellpx)); top: calc(1 * var(--cellpx)); }
    .k-2g{ left: calc(6 * var(--cellpx)); top: calc(1 * var(--cellpx)); }

    /* ========= UI-BEREICH (ab Zeile 9 = direkt unter Board-Zeile 8) ========= */
    .ui{
      grid-column: 1 / span 8;
      grid-row: 11 / span 3; /* UI-Start direkt unter Board (nach 01/02 + 1..8) */
      z-index: 20;
      display:flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: calc(var(--cellpx) * 0.15);
      padding: 0 calc(var(--cellpx) * 0.25);
      box-sizing: border-box;
      background: transparent; /* ✅ keine Fläche */
    }

    .kippspeedLabel{
      font-weight: 1000;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      color: var(--ui-text);
      text-shadow: 0 1px 0 rgba(0,0,0,0.35);
      font-size: 16px;
      line-height: 1.05;
      text-align: center;
      user-select:none;
      white-space: nowrap;
    }

    .squareBtn{
      width: 44px;
      height: 44px;
      border-radius: 0;
      border: 2px solid rgba(0,0,0,0.55);
      background:
        linear-gradient(180deg, rgba(255,255,255,0.14), rgba(0,0,0,0.05)),
        var(--btn-bg);
      box-shadow:
        0 18px 22px rgba(0,0,0,0.35),
        0 8px 14px rgba(0,0,0,0.22),
        0 0 0 1px rgba(255,255,255,0.18) inset;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
    }
    .squareBtn:active{ transform: scale(0.985); filter: brightness(0.98); }

    .playIcon{
      width: 0; height: 0;
      border-top: 11px solid transparent;
      border-bottom: 11px solid transparent;
      border-left: 18px solid #7a3f2b;
      filter: drop-shadow(0 1px 0 rgba(255,255,255,0.25));
      transform: translateX(1px);
    }
    .pauseIcon{
      width: 18px;
      height: 22px;
      position: relative;
      filter: drop-shadow(0 1px 0 rgba(255,255,255,0.25));
    }
    .pauseIcon::before,
    .pauseIcon::after{
      content:"";
      position:absolute;
      top:0;
      width: 6px;
      height: 22px;
      background: #7a3f2b;
      border-radius: 1px;
    }
    .pauseIcon::before{ left: 0; }
    .pauseIcon::after { right: 0; }

    .okText{
      font-weight: 1000;
      letter-spacing: 0.06em;
      color: #7a3f2b;
      text-shadow: 0 1px 0 rgba(255,255,255,0.35);
      font-size: 16px;
      line-height: 1;
    }

    .sliderRow{
      width: 100%;
      display:flex;
      align-items:center;
      gap: 14px;
      justify-content: center;
    }

    .speedIcon{
      width: clamp(44px, 10vmin, 62px);
      height: clamp(44px, 10vmin, 62px);
      opacity: 0.98;
      flex: 0 0 auto;
      filter:
        brightness(0) saturate(100%)
        invert(90%) sepia(16%) saturate(330%)
        hue-rotate(355deg) brightness(105%) contrast(95%)
        drop-shadow(0 1px 0 rgba(0,0,0,0.35))
        drop-shadow(0 2px 6px rgba(0,0,0,0.25));
    }

    input[type="range"]{
      -webkit-appearance: none;
      appearance: none;
      width: min(520px, 100%);
      height: 10px;
      border-radius: 999px;
      background: rgba(0,0,0,0.15);
      outline: none;
      border: 1px solid rgba(0,0,0,0.35);
      box-shadow:
        0 0 0 1px rgba(255,255,255,0.10) inset,
        0 1px 0 rgba(0,0,0,0.35) inset;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance: none;
      appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 6px;
      background: var(--btn-bg);
      border: 2px solid rgba(0,0,0,0.35);
      box-shadow:
        0 8px 14px rgba(0,0,0,0.22),
        0 0 0 1px rgba(255,255,255,0.18) inset;
      cursor: pointer;
    }

    .speedTop{
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 10px;
    }

    .modeBlock.hidden{ display:none !important; }

    /* ===== GameMode (ab Zeile 9 Bereich, gleiches UI-Anchor) ===== */
    .gameConsole{
      width:100%;
      display:flex;
      flex-direction: column;
      align-items:center;
      gap: 10px;
    }

    .previewHint{
      text-align:center;
      font-weight: 1000;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      color: var(--ui-text);
      text-shadow: 0 1px 0 rgba(0,0,0,0.35);
      font-size: clamp(14px, 5.2vmin, 20px);
      user-select:none;
    }

    .gcBtn{
      width: min(520px, 100%);
      border: 1px solid rgba(0,0,0,0.35);
      background: var(--btn-bg);
      color: var(--btn-text);
      font-weight: 1000;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      padding: 12px 12px;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: 0 10px 18px rgba(0,0,0,0.25), 0 0 0 1px rgba(255,255,255,0.15) inset;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    .gcBtn:active{ transform: translateY(1px) scale(0.99); filter: brightness(0.97); }

    .levelRow{
      width: min(520px, 100%);
      display:flex;
      gap: 10px;
    }
    .levelBtn{
      flex: 1 1 0;
      border: 1px solid rgba(0,0,0,0.35);
      background: rgba(234,215,190,0.95);
      color: #2a160c;
      font-weight: 1000;
      font-size: clamp(12px, 4vmin, 18px);
      letter-spacing: 0.04em;
      line-height: 1.05;
      padding: 12px 8px;
      border-radius: 12px;
      cursor: pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      box-shadow:
        0 10px 18px rgba(0,0,0,0.20),
        0 0 0 1px rgba(255,255,255,0.12) inset;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .levelBtn:active{ transform: translateY(1px) scale(0.99); filter: brightness(0.97); }

    .kippCountTitle{
      font-weight: 1000;
      letter-spacing: 0.10em;
      color: var(--ui-text);
      text-shadow: 0 1px 0 rgba(0,0,0,0.35);
      font-size: clamp(18px, 5.6vmin, 34px);
      line-height: 0.95;
      text-align: center;
      user-select:none;
      margin: 6px 0 6px 0;
      text-transform: none;
    }
    .kippStatus{
      font-weight: 1000;
      letter-spacing: 0.08em;
      color: var(--ui-text);
      text-shadow: 0 1px 0 rgba(0,0,0,0.35);
      font-size: clamp(12px, 3.9vmin, 16px);
      line-height: 1.05;
      margin: 0 0 6px 0;
      user-select:none;
      text-transform: none;
      text-align: center;
    }
    .kippGoalWord{ font-weight: 1000; }

    .gcRow{
      width: min(520px, 100%);
      display:flex;
      gap: 8px;
      justify-content: space-between;
      align-items:center;
    }

    .miniBtn{
      flex: 1 1 0;
      border: 1px solid rgba(0,0,0,0.35);
      background: rgba(234,215,190,0.95);
      color: #2a160c;
      font-weight: 1000;
      font-size: clamp(14px, 5.5vmin, 22px);
      line-height: 1;
      padding: 7px 0;
      border-radius: 10px;
      cursor: pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      box-shadow:
        0 10px 18px rgba(0,0,0,0.20),
        0 0 0 1px rgba(255,255,255,0.12) inset;
    }
    .miniBtn:active{ transform: translateY(1px) scale(0.99); }
    .miniBtn.sel{
      background: rgba(0,0,0,0.18);
      color: var(--ui-text);
      border-color: rgba(0,0,0,0.55);
    }
    .miniBtn[disabled]{ opacity: 0.55; cursor: default; filter: grayscale(0.1); }

    @keyframes blinkSoft{ 0%, 100% { opacity: 1; } 50% { opacity: 0.35; } }
    @keyframes pulseSoft{ 0%, 100% { transform: scale(1); } 50% { transform: scale(1.06); } }

    .attnSpeed .kippspeedLabel{ animation: blinkSoft 1.4s ease-in-out infinite; }
    .attnPlay #btnPlay{ animation: blinkSoft 0.9s ease-in-out infinite; }
    #decisionPanel.pulseSeq .miniBtn{ animation: pulseSoft 1.15s ease-in-out infinite; }
    #decisionPanel.pulseSeq .miniBtn:nth-child(1){ animation-delay: 0.00s; }
    #decisionPanel.pulseSeq .miniBtn:nth-child(2){ animation-delay: 0.10s; }
    #decisionPanel.pulseSeq .miniBtn:nth-child(3){ animation-delay: 0.20s; }

    /* ========= SCORE (zwischen Zeile 13 und 14) – KEINE eigene Fläche ========= */
    .scoreRow{
      grid-column: 1 / span 8;
      grid-row: 15 / span 2; /* entspricht "zwischen 13 und 14" im Board+UI-Sinn (unter UI-Start) */
      z-index: 25;
      display:flex;
      align-items:center;
      justify-content: space-between;
      padding: 0 calc(var(--cellpx) * 0.25);
      box-sizing: border-box;
      background: transparent; /* ✅ keine Fläche */
    }
    .kippBilanzBtn{
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.35);
      background: var(--btn-bg);
      color: var(--btn-text);
      font-weight: 1000;
      letter-spacing: 0.06em;
      padding: 12px 16px;
      cursor: pointer;
      box-shadow: 0 10px 18px rgba(0,0,0,0.25), 0 0 0 1px rgba(255,255,255,0.15) inset;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      white-space: nowrap;
    }
    .kippBilanzBtn:active{ transform: translateY(1px) scale(0.99); filter: brightness(0.97); }

    .gcPoints{
      font-weight: 1000;
      color: var(--ui-text);
      text-shadow: 0 1px 0 rgba(0,0,0,0.35);
      font-size: 34px;
      line-height: 0.95;
      letter-spacing: 0.02em;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }
  </style>
</head>

<body>
  <div class="stage">
    <div class="layout" id="layout">
      <div class="bgPNG" aria-hidden="true"></div>

      <!-- HEADER (01–02) -->
      <button id="backBtn" class="navBtn headerBack" aria-label="Zurück zur Speed-Einstellung" type="button">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M15 5L8 12l7 7"></path>
        </svg>
      </button>

      <div class="headerTitle" aria-label="Titel">KIPP COLOR</div>

      <button id="exitBtnTop" class="navBtn headerExit" aria-label="Spiel beenden" type="button">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M6 6l12 12M18 6L6 18"></path>
        </svg>
      </button>

      <!-- BOARD (1–8) -->
      <div class="board" id="board" aria-label="Spielfeld">
        <div id="grid" class="grid" aria-label="8×8 Raster"></div>

        <div id="wFaceGroup" class="wFaceGroup" aria-label="W Paket">
          <div class="cubeShadow" aria-hidden="true"></div>
          <div class="cubeFace" aria-label="Würfelfläche"></div>

          <div class="slot s-3b read-west"  data-slot="S1"><div class="num"><span></span></div></div>
          <div class="slot s-4b read-west"  data-slot="S2"><div class="num"><span></span></div></div>
          <div class="slot s-2c read-north" data-slot="S3"><div class="num"><span></span></div></div>
          <div class="slot s-2d read-north" data-slot="S4"><div class="num"><span></span></div></div>
        </div>

        <div id="kipGroup" class="kipGroup hidden" aria-label="KIP Gruppe">
          <div class="kipScale">
            <div class="kipShadow" aria-hidden="true"></div>
            <div class="kipEdgeCore" aria-hidden="true"></div>

            <div class="cubeFace kipFaceQ0" aria-label="Würfelfläche Q0"></div>
            <div class="cubeFace kipFaceQ1" aria-label="Würfelfläche Q1"></div>

            <div class="slot k-4d read-east"  data-slot="W2_A"><div class="num"><span></span></div></div>
            <div class="slot k-3d read-east"  data-slot="W2_B"><div class="num"><span></span></div></div>
            <div class="slot k-2b read-north" data-slot="W2_C"><div class="num"><span></span></div></div>
            <div class="slot k-2c read-north" data-slot="W2_D"><div class="num"><span></span></div></div>

            <div class="slot k-3e read-west"  data-slot="W1_1"><div class="num"><span></span></div></div>
            <div class="slot k-4e read-west"  data-slot="W1_2"><div class="num"><span></span></div></div>
            <div class="slot k-2f read-north" data-slot="W1_3"><div class="num"><span></span></div></div>
            <div class="slot k-2g read-north" data-slot="W1_4"><div class="num"><span></span></div></div>
          </div>
        </div>

        <div class="ball" aria-label="Kugel"></div>
      </div>

      <!-- UI ab Zeile 9 (unterhalb Board) -->
      <div class="ui" id="ui">
        <div id="speedMode" class="modeBlock">
          <div class="speedTop">
            <div class="kippspeedLabel" id="kippspeedLabel">KIPP SPEED (KSP)</div>

            <button id="btnPlay" class="squareBtn" aria-label="Demo starten/pausieren" type="button">
              <span id="playGlyph" class="playIcon" aria-hidden="true"></span>
            </button>

            <button id="btnOk" class="squareBtn" aria-label="Geschwindigkeit bestätigen" type="button">
              <span class="okText">OK</span>
            </button>
          </div>

          <div class="sliderRow">
            <img class="speedIcon" src="kippspeed_snail_tight.png" alt="langsam">
            <input id="speedSlider" type="range" min="0" max="9" value="3" step="1" aria-label="Speed Slider">
            <img class="speedIcon" src="kippspeed_hase_tight.png" alt="schnell">
          </div>
        </div>

        <div id="gameMode" class="modeBlock hidden">
          <div class="gameConsole">
            <div id="previewHint" class="previewHint">SCHAU GENAU!</div>
            <button id="btnSetNumbers" class="gcBtn set" type="button">VORSCHAU-KIPPS</button>

            <div id="levelPanel" class="hidden">
              <div class="previewHint" id="levelTitle">LEVEL WÄHLEN</div>
              <div class="levelRow">
                <button id="btnLevelTrainee" class="levelBtn" type="button">Trainee</button>
                <button id="btnLevelBrainy"  class="levelBtn" type="button">Brainy</button>
                <button id="btnLevelBrain"   class="levelBtn" type="button">Brain</button>
              </div>
            </div>

            <div id="decisionPanel" class="hidden">
              <div class="kippCountTitle" id="kippTitle">KIPP Anzahl wählen</div>
              <div class="kippStatus" id="kippStatus">Tippe auf eine Taste</div>

              <div class="gcRow" aria-label="Kippanzahl">
                <button class="miniBtn" data-k="3" type="button">3</button>
                <button class="miniBtn" data-k="6" type="button">6</button>
                <button class="miniBtn" data-k="9" type="button">9</button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- SCORE zwischen Zeile 13 und 14 (ohne Fläche) -->
      <div class="scoreRow" id="scoreRow">
        <button id="btnKippBilanz" class="kippBilanzBtn" type="button" aria-label="KIPP Bilanz">KIPP Bilanz</button>
        <div id="gcPoints" class="gcPoints">P00/80</div>
      </div>

    </div>
  </div>

  <script>
    const layoutEl    = document.getElementById("layout");
    const boardEl     = document.getElementById("board");
    const grid        = document.getElementById("grid");
    const wFace       = document.getElementById("wFaceGroup");
    const kipGroup    = document.getElementById("kipGroup");
    const speedSlider = document.getElementById("speedSlider");

    const speedMode   = document.getElementById("speedMode");
    const gameMode    = document.getElementById("gameMode");

    const btnKippBilanz = document.getElementById("btnKippBilanz");
    const btnPlay     = document.getElementById("btnPlay");
    const playGlyph   = document.getElementById("playGlyph");
    const btnOk       = document.getElementById("btnOk");
    const backBtn     = document.getElementById("backBtn");
    const exitBtnTop  = document.getElementById("exitBtnTop");

    const btnSetNumbers   = document.getElementById("btnSetNumbers");
    const decisionPanel   = document.getElementById("decisionPanel");
    const levelPanel      = document.getElementById("levelPanel");
    const levelTitle      = document.getElementById("levelTitle");
    const btnLevelTrainee = document.getElementById("btnLevelTrainee");
    const btnLevelBrainy  = document.getElementById("btnLevelBrainy");
    const btnLevelBrain   = document.getElementById("btnLevelBrain");

    const previewHintEl = document.getElementById("previewHint");
    const kippTitleEl   = document.getElementById("kippTitle");
    const kippStatusEl  = document.getElementById("kippStatus");

    const gcPoints = document.getElementById("gcPoints");

    function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

    /* ✅ ZENTRAL: cellpx = layoutBreite/8 -> damit PNG NICHT 50% wird */
    function setCellPx(){
      const w = Math.round(layoutEl.getBoundingClientRect().width);
      const cell = Math.round(w / 8);
      document.documentElement.style.setProperty("--cellpx", cell + "px");
    }

    function getTiming(){
      const v = Number(speedSlider.value || 3);
      const hold = Math.max(520, Math.round(2200 - v * 186));
      const kip = Math.max(160, Math.round(hold * 0.50));
      const wfull = hold;
      return { holdMs: hold, kipMs: kip, wMs: wfull };
    }

    const cols = ["A","B","C","D","E","F","G","H"];
    function key(r, cLetter){ return `${r}${cLetter}`; }

    const colorMap = new Map([
      [key(3,"A"), "c-orange"],
      [key(4,"A"), "c-gruen"],
      [key(5,"A"), "c-violett"],
      [key(6,"A"), "c-blau"],

      [key(8,"C"), "c-gruen"],
      [key(8,"D"), "c-orange"],
      [key(8,"E"), "c-gruen"],
      [key(8,"F"), "c-orange"],

      [key(6,"H"), "c-violett"],
      [key(5,"H"), "c-blau"],
      [key(4,"H"), "c-orange"],
      [key(3,"H"), "c-gruen"],

      [key(1,"F"), "c-blau"],
      [key(1,"E"), "c-violett"],
      [key(1,"D"), "c-blau"],
      [key(1,"C"), "c-violett"],
    ]);

    function buildGridOnce(){
      if (grid.dataset.built === "1") return;
      for(let r=1; r<=8; r++){
        for(let c=0; c<8; c++){
          const cell = document.createElement("div");
          cell.className = "cell";
          const coord = key(r, cols[c]);
          cell.dataset.coord = coord;
          if(colorMap.has(coord)){
            const cls = colorMap.get(coord);
            cell.classList.add(cls);
            cell.classList.add("colorCell");
          }
          grid.appendChild(cell);
        }
      }
      grid.dataset.built = "1";
    }

    function renderNumber(span, n){
      if(!span) return;
      span.textContent = (n === null || n === undefined) ? "" : String(n);
    }

    function getUniqueRandomNumbers(count, min, max){
      const pool = [];
      for(let i=min; i<=max; i++) pool.push(i);
      for(let i=pool.length-1; i>0; i--){
        const j = Math.floor(Math.random() * (i+1));
        [pool[i], pool[j]] = [pool[j], pool[i]];
      }
      return pool.slice(0, count);
    }

    const rotDeg = [0, 90, 180, 270];
    let rotIndex  = 0;
    let faceIndex = 0;

    function setRotationSnap(){
      const deg = rotDeg[rotIndex];
      wFace.style.setProperty("--rot", deg + "deg");
      kipGroup.style.setProperty("--rot", deg + "deg");
    }

    function advanceFullCW(){
      rotIndex  = (rotIndex + 1) % 4;
      faceIndex = (faceIndex + 1) % 3;
      setRotationSnap();
    }

    const slotTargetsW = [
      wFace.querySelector('[data-slot="S1"] .num > span'),
      wFace.querySelector('[data-slot="S2"] .num > span'),
      wFace.querySelector('[data-slot="S3"] .num > span'),
      wFace.querySelector('[data-slot="S4"] .num > span'),
    ];

    const slotTargetsKipRight = [
      kipGroup.querySelector('[data-slot="W1_1"] .num > span'),
      kipGroup.querySelector('[data-slot="W1_2"] .num > span'),
      kipGroup.querySelector('[data-slot="W1_3"] .num > span'),
      kipGroup.querySelector('[data-slot="W1_4"] .num > span'),
    ];

    const slotTargetsKipLeft = [
      kipGroup.querySelector('[data-slot="W2_A"] .num > span'),
      kipGroup.querySelector('[data-slot="W2_B"] .num > span'),
      kipGroup.querySelector('[data-slot="W2_C"] .num > span'),
      kipGroup.querySelector('[data-slot="W2_D"] .num > span'),
    ];

    function clearAllNumbers(){
      [...slotTargetsW, ...slotTargetsKipRight, ...slotTargetsKipLeft].forEach(s => { if(s) s.textContent = ""; });
    }

    function showW(){
      kipGroup.classList.add("hidden");
      wFace.classList.remove("hidden");
    }
    function showKip(){
      wFace.classList.add("hidden");
      kipGroup.classList.remove("hidden");
    }

    function renderWEmpty(){
      setRotationSnap();
      for(let i=0;i<4;i++) renderNumber(slotTargetsW[i], null);
    }

    function renderKipEmpty(){
      setRotationSnap();
      for(let i=0;i<4;i++){
        renderNumber(slotTargetsKipRight[i], null);
        renderNumber(slotTargetsKipLeft[i], null);
      }
    }

    function resetToW1Q0_Empty(){
      rotIndex = 0;
      faceIndex = 0;
      setRotationSnap();
      clearAllNumbers();
      showW();
      renderWEmpty();
    }

    let hasAdjustedOnce = false;

    let runningDemo     = false;
    let demoPaused      = false;
    let demoToken       = 0;

    let runningSet      = false;
    let setToken        = 0;

    function setPlayGlyph(isPause){
      playGlyph.className = isPause ? "pauseIcon" : "playIcon";
    }

    function showSpeedMode(){
      speedMode.classList.remove("hidden");
      gameMode.classList.add("hidden");
      if(previewHintEl) previewHintEl.classList.remove("hidden");
      setPlayGlyph(false);
    }

    function showGameMode(){
      speedMode.classList.add("hidden");
      gameMode.classList.remove("hidden");

      btnSetNumbers.classList.remove("hidden");
      decisionPanel.classList.add("hidden");
      levelPanel.classList.add("hidden");

      if(previewHintEl) previewHintEl.classList.remove("hidden");

      setPoints(0);
    }

    async function waitOrPause(ms, myToken){
      const slice = 40;
      let elapsed = 0;
      while(elapsed < ms){
        if(myToken !== demoToken) return false;
        if(demoPaused){
          await sleep(60);
          continue;
        }
        const step = Math.min(slice, ms - elapsed);
        await sleep(step);
        elapsed += step;
      }
      return (myToken === demoToken);
    }

    async function runDemoCycle(){
      if(runningDemo) return;
      runningDemo = true;
      demoPaused = false;
      const myToken = ++demoToken;

      const T = getTiming();

      showKip(); renderKipEmpty();
      if(!await waitOrPause(T.kipMs, myToken)) { runningDemo=false; return; }

      advanceFullCW(); showW(); renderWEmpty();
      if(!await waitOrPause(T.wMs, myToken)) { runningDemo=false; return; }

      showKip(); renderKipEmpty();
      if(!await waitOrPause(T.kipMs, myToken)) { runningDemo=false; return; }

      advanceFullCW(); showW(); renderWEmpty();
      if(!await waitOrPause(T.wMs, myToken)) { runningDemo=false; return; }

      showKip(); renderKipEmpty();
      if(!await waitOrPause(T.kipMs, myToken)) { runningDemo=false; return; }

      advanceFullCW(); showW(); renderWEmpty();
      if(!await waitOrPause(T.wMs, myToken)) { runningDemo=false; return; }

      showKip(); renderKipEmpty();
      if(!await waitOrPause(T.kipMs, myToken)) { runningDemo=false; return; }

      advanceFullCW(); showW(); renderWEmpty();
      if(!await waitOrPause(T.wMs, myToken)) { runningDemo=false; return; }

      runningDemo = false;
    }

    function cancelDemo(){
      demoToken++;
      runningDemo = false;
      demoPaused = false;
      setPlayGlyph(false);
    }

    let planned = [
      [null,null,null,null],
      [null,null,null,null],
      [null,null,null,null],
    ];
    let sets = [
      [null,null,null,null],
      [null,null,null,null],
      [null,null,null,null],
    ];
    let assigned = [false,false,false];

    function ensureAssigned(idx){
      if(assigned[idx]) return;
      sets[idx] = planned[idx].slice();
      assigned[idx] = true;
    }

    function renderW(){
      setRotationSnap();
      const curr = sets[faceIndex];
      for(let i=0;i<4;i++) renderNumber(slotTargetsW[i], curr[i]);
    }

    function mapHiddenToVisible_CW(face){
      const [f1,f2,f3,f4] = face;
      return [f4, f3, f2, f1];
    }

    function renderKip(){
      setRotationSnap();
      const curr = sets[faceIndex];
      const nextFaceIndex = (faceIndex + 1) % 3;
      const next = sets[nextFaceIndex];

      for(let i=0;i<4;i++) renderNumber(slotTargetsKipRight[i], curr[i]);
      const nextPreview = mapHiddenToVisible_CW(next);
      for(let i=0;i<4;i++) renderNumber(slotTargetsKipLeft[i], nextPreview[i]);
    }

    function reroll12_keepEmpty(){
      const twelve = getUniqueRandomNumbers(12, 1, 12);
      planned[0] = twelve.slice(0,4);
      planned[1] = twelve.slice(4,8);
      planned[2] = twelve.slice(8,12);

      sets = [
        [null,null,null,null],
        [null,null,null,null],
        [null,null,null,null],
      ];
      assigned = [false,false,false];

      rotIndex  = 0;
      faceIndex = 0;

      clearAllNumbers();
      setRotationSnap();
    }

    function beginLevelChoice(){
      btnSetNumbers.classList.add("hidden");
      decisionPanel.classList.add("hidden");
      levelPanel.classList.remove("hidden");

      if(previewHintEl) previewHintEl.classList.add("hidden");
      levelTitle.textContent = "LEVEL WÄHLEN";
    }

    async function runSetNumbersCycle(){
      if(runningSet) return;
      runningSet = true;
      const myToken = ++setToken;

      reroll12_keepEmpty();
      const T = getTiming();

      showW(); renderWEmpty();
      await sleep(T.wMs);
      if(myToken!==setToken){ runningSet=false; return; }

      ensureAssigned(0); renderW();
      await sleep(T.wMs);
      if(myToken!==setToken){ runningSet=false; return; }

      showKip(); renderKip();
      await sleep(T.kipMs);
      if(myToken!==setToken){ runningSet=false; return; }

      advanceFullCW(); showW(); renderWEmpty();
      await sleep(T.wMs);
      if(myToken!==setToken){ runningSet=false; return; }

      ensureAssigned(1); renderW();
      await sleep(T.wMs);
      if(myToken!==setToken){ runningSet=false; return; }

      showKip(); renderKip();
      await sleep(T.kipMs);
      if(myToken!==setToken){ runningSet=false; return; }

      advanceFullCW(); showW(); renderWEmpty();
      await sleep(T.wMs);
      if(myToken!==setToken){ runningSet=false; return; }

      ensureAssigned(2); renderW();
      await sleep(T.wMs);
      if(myToken!==setToken){ runningSet=false; return; }

      showKip(); renderKip();
      await sleep(T.kipMs);
      if(myToken!==setToken){ runningSet=false; return; }

      advanceFullCW();
      showW();
      renderW();

      const EXTRA_KIPPS_AFTER_END = 3;

      await sleep(T.wMs);
      if(myToken!==setToken){ runningSet=false; return; }

      for(let j=0; j<EXTRA_KIPPS_AFTER_END; j++){
        showKip();
        renderKip();
        await sleep(T.kipMs);
        if(myToken!==setToken){ runningSet=false; return; }

        advanceFullCW();

        showW();
        renderW();
        await sleep(T.wMs);
        if(myToken!==setToken){ runningSet=false; return; }
      }

      runningSet = false;
      beginLevelChoice();
    }

    function cancelSetNumbers(){
      setToken++;
      runningSet = false;
    }

    function clearTargets(){
      Array.from(grid.querySelectorAll(".targetBadge")).forEach(el => el.remove());
    }

    function sideClassForCoord(coord){
      const r = parseInt(coord, 10);
      const c = coord.replace(String(r), "");
      if(r === 1) return "trot-top";
      if(r === 8) return "trot-bottom";
      if(c === "A") return "trot-left";
      if(c === "H") return "trot-right";
      return "trot-bottom";
    }

    function showTargetOnAllSameColor(colorClass, n){
      clearTargets();
      Array.from(grid.children).forEach(cell=>{
        if(!cell.classList.contains("colorCell")) return;
        if(!cell.classList.contains(colorClass)) return;

        const coord = cell.dataset.coord;
        const badge = document.createElement("div");
        badge.className = "targetBadge " + sideClassForCoord(coord);
        badge.textContent = String(n);
        cell.appendChild(badge);
      });
    }

    function colorRgbForClass(colorClass){
      const css = getComputedStyle(document.documentElement);
      if(colorClass === "c-orange")  return css.getPropertyValue("--orange").trim();
      if(colorClass === "c-gruen")   return css.getPropertyValue("--gruen").trim();
      if(colorClass === "c-violett") return css.getPropertyValue("--violett").trim();
      if(colorClass === "c-blau")    return css.getPropertyValue("--blau").trim();
      return css.getPropertyValue("--ui-text").trim();
    }

    /* ===== Spielregeln ===== */
    const MAX_ROUNDS = 10;
    const MAX_TRIES  = 3;
    const SCORE_BY_TRY = [8,5,3];

    let roundIndex = 0;
    let tryIndex   = 0;
    let points     = 0;

    let currentTargetColor = null;
    let currentTargetNumber = null;

    function setPoints(p){
      points = Math.max(0, p|0);
      const s = String(points).padStart(2, "0");
      gcPoints.textContent = "P" + s + "/80";
    }

    // Rotation-Helpers
    const colToX = {A:1,B:2,C:3,D:4,E:5,F:6,G:7,H:8};
    const xToCol = ["","A","B","C","D","E","F","G","H"];

    function parseCoord(coord){
      const r = parseInt(coord, 10);
      const c = coord.replace(String(r), "");
      return { x: colToX[c], y: r };
    }
    function makeCoord(x,y){
      return `${y}${xToCol[x]}`;
    }
    function rotateCoordCW(coord, times){
      let {x,y} = parseCoord(coord);
      let t = ((times%4)+4)%4;
      for(let i=0;i<t;i++){
        const nx = y;
        const ny = 9 - x;
        x = nx; y = ny;
      }
      return makeCoord(x,y);
    }

    const BASE_SLOT_COORDS = ["3B","4B","2C","2D"];

    function currentInnerMap(){
      const curr = sets[faceIndex] || [];
      const map = new Map();
      for(let i=0;i<4;i++){
        const base = BASE_SLOT_COORDS[i];
        const abs  = rotateCoordCW(base, rotIndex);
        const n    = curr[i];
        if(n != null) map.set(abs, n);
      }
      return map;
    }

    const TARGET_COORDS = [
      "3A","4A","5A","6A",
      "3H","4H","5H","6H",
      "1C","1D","1E","1F",
      "8C","8D","8E","8F",
    ];

    function adjacentInnerCoordForTarget(targetCoord){
      const {x,y} = parseCoord(targetCoord);
      if(x === 1) return makeCoord(2, y);
      if(x === 8) return makeCoord(7, y);
      if(y === 1) return makeCoord(x, 2);
      if(y === 8) return makeCoord(x, 7);
      return null;
    }

    function getCubeQuadrant(){
      return rotIndex;
    }

    function quadrantOfCoord(coord){
      const {x,y} = parseCoord(coord);
      const left  = (x <= 4);
      const top   = (y <= 4);
      if(top && left) return 0;
      if(top && !left) return 1;
      if(!top && !left) return 2;
      return 3;
    }

    const QUAD_FIELD_COORDS = {
      0: {1:"4A", 2:"3A", 3:"1C", 4:"1D"},
      1: {1:"1E", 2:"1F", 3:"3H", 4:"4H"},
      2: {1:"5H", 2:"6H", 3:"8F", 4:"8E"},
      3: {1:"8D", 2:"8C", 3:"6A", 4:"5A"},
    };

    function fieldIdForTargetCoord(coord, quad){
      const q = QUAD_FIELD_COORDS[quad];
      if(!q) return null;
      for(const fid of [1,2,3,4]){
        if(q[fid] === coord) return fid;
      }
      return null;
    }

    function slotIdAtInnerCoord(innerCoord){
      for(let i=0;i<4;i++){
        const abs = rotateCoordCW(BASE_SLOT_COORDS[i], rotIndex);
        if(abs === innerCoord) return (i+1);
      }
      return null;
    }

    function ordinalDeTitle(k){
      const map = ["Erstes","Zweites","Drittes","Viertes","Fünftes","Sechstes","Siebentes","Achtes","Neuntes","Zehntes"];
      if(k >= 1 && k <= 10) return map[k-1];
      return "Nächstes";
    }

    function setGoalInfoText(roundOneBased){
      const ord = ordinalDeTitle(roundOneBased);
      const rgb = colorRgbForClass(currentTargetColor);
      kippTitleEl.innerHTML = `${ord} <span class="kippGoalWord" style="color:${rgb};">KIPP-ZIEL</span> (von zehn)`;
      kippStatusEl.textContent = "Wähle deine KIPP Anzahl";
    }

    function setTryText(){
      if(tryIndex === 0){
        kippTitleEl.textContent  = "KIPP Anzahl wählen";
        kippStatusEl.textContent = "Tippe auf eine Taste";
      }else if(tryIndex === 1){
        kippTitleEl.textContent  = "ZWEITER VERSUCH";
        kippStatusEl.textContent = "KIPPANZAHL WÄHLEN";
      }else{
        kippTitleEl.textContent  = "LETZTER VERSUCH";
        kippStatusEl.textContent = "KIPPANZAHL WÄHLEN";
      }
    }

    function startPulse(){ decisionPanel.classList.add("pulseSeq"); }
    function stopPulse(){ decisionPanel.classList.remove("pulseSeq"); }

    let selectedKippCount = null;

    function setButtonsEnabled(enabled){
      document.querySelectorAll('.miniBtn[data-k]').forEach(btn=>{
        btn.disabled = !enabled;
      });
    }

    function selectKippCount(k){
      selectedKippCount = (k == null) ? null : Number(k);
      document.querySelectorAll('.miniBtn[data-k]').forEach(btn=>{
        btn.classList.toggle("sel", Number(btn.dataset.k) === selectedKippCount);
      });
      if(selectedKippCount != null) stopPulse();
    }

    let busyMove = false;

    function isHitForTarget(inner, targetColor, targetNumber){
      const quad = getCubeQuadrant();

      const candidates = TARGET_COORDS
        .filter(tc => colorMap.get(tc) === targetColor)
        .filter(tc => quadrantOfCoord(tc) === quad);

      for(const tc of candidates){
        const fid = fieldIdForTargetCoord(tc, quad);
        if(fid == null) continue;

        const adj = adjacentInnerCoordForTarget(tc);
        if(!adj) continue;

        const sid = slotIdAtInnerCoord(adj);
        if(sid == null) continue;

        if(sid !== fid) continue;

        if(inner.get(adj) === targetNumber) return true;
      }
      return false;
    }

    function pickNewTarget(){
      const inner = currentInnerMap();
      const visibleNums = Array.from(new Set(Array.from(inner.values())));

      if(visibleNums.length === 0){
        currentTargetColor = "c-orange";
        currentTargetNumber = 1;
        showTargetOnAllSameColor(currentTargetColor, currentTargetNumber);
        return;
      }

      const allColors = Array.from(new Set(TARGET_COORDS.map(tc=>colorMap.get(tc)).filter(Boolean)));

      let guard = 0;
      while(guard < 200){
        const col = allColors[Math.floor(Math.random()*allColors.length)] || "c-orange";
        const n   = visibleNums[Math.floor(Math.random()*visibleNums.length)];
        const hitNow = isHitForTarget(inner, col, n);
        if(!hitNow){
          currentTargetColor = col;
          currentTargetNumber = n;
          showTargetOnAllSameColor(currentTargetColor, currentTargetNumber);
          return;
        }
        guard++;
      }

      currentTargetColor = allColors[Math.floor(Math.random()*allColors.length)] || "c-orange";
      currentTargetNumber = visibleNums[Math.floor(Math.random()*visibleNums.length)];
      showTargetOnAllSameColor(currentTargetColor, currentTargetNumber);
    }

    function evaluateHit(){
      if(!currentTargetColor || currentTargetNumber == null) return false;
      const inner = currentInnerMap();
      return isHitForTarget(inner, currentTargetColor, currentTargetNumber);
    }

    async function performKippCW(count){
      if(busyMove) return;
      if(!count) return;

      busyMove = true;
      setButtonsEnabled(false);

      const c = Math.max(1, Math.min(9, Number(count)));
      const T = getTiming();

      for(let i=0; i<c; i++){
        showKip();
        renderKip();
        await sleep(T.kipMs);

        advanceFullCW();

        showW();
        renderW();
        await sleep(T.wMs);
      }

      const hit = evaluateHit();

      if(hit){
        const add = SCORE_BY_TRY[Math.min(tryIndex, SCORE_BY_TRY.length-1)] || 0;
        setPoints(points + add);

        roundIndex++;
        tryIndex = 0;

        if(roundIndex >= MAX_ROUNDS){
          clearTargets();
          alert("ENDE! Punkte: " + points);
          showSpeedMode();
          busyMove = false;
          setButtonsEnabled(true);
          return;
        }

        pickNewTarget();
        setGoalInfoText(roundIndex + 1);

      }else{
        tryIndex++;

        if(tryIndex >= MAX_TRIES){
          roundIndex++;
          tryIndex = 0;

          if(roundIndex >= MAX_ROUNDS){
            clearTargets();
            alert("ENDE! Punkte: " + points);
            showSpeedMode();
            busyMove = false;
            setButtonsEnabled(true);
            return;
          }

          pickNewTarget();
          setGoalInfoText(roundIndex + 1);
        }
      }

      selectKippCount(null);
      setTryText();
      startPulse();
      setButtonsEnabled(true);

      busyMove = false;
    }

    document.querySelectorAll('.miniBtn[data-k]').forEach(btn=>{
      btn.addEventListener("click", () => {
        if(busyMove) return;
        selectKippCount(btn.dataset.k);
        performKippCW(selectedKippCount);
      });
    });

    function beginPlayerPhase(){
      levelPanel.classList.add("hidden");
      btnSetNumbers.classList.add("hidden");
      decisionPanel.classList.remove("hidden");

      roundIndex = 0;
      tryIndex = 0;
      setPoints(points);

      pickNewTarget();
      setTryText();

      selectKippCount(null);
      startPulse();
      setButtonsEnabled(true);

      setGoalInfoText(1);
      setTryText();
    }

    speedSlider.addEventListener("input", () => {
      hasAdjustedOnce = true;
      if(!runningDemo){
        // optisch: Play blinkt nicht mehr gesteuert über Klassen – hier minimal
      }
    });

    btnPlay.addEventListener("click", async () => {
      if(!hasAdjustedOnce){
        // ok
      }

      if(!runningDemo){
        setPlayGlyph(true);
        await runDemoCycle();
        setPlayGlyph(false);
        return;
      }

      demoPaused = !demoPaused;
      setPlayGlyph(demoPaused ? false : true);
    });

    btnOk.addEventListener("click", () => {
      cancelDemo();
      cancelSetNumbers();
      resetToW1Q0_Empty();
      showGameMode();
    });

    btnSetNumbers.addEventListener("click", async () => {
      if(previewHintEl) previewHintEl.classList.remove("hidden");
      await runSetNumbersCycle();
    });

    backBtn.addEventListener("click", () => {
      cancelDemo();
      cancelSetNumbers();
      busyMove = false;
      clearTargets();

      levelPanel.classList.add("hidden");
      decisionPanel.classList.add("hidden");

      resetToW1Q0_Empty();
      showSpeedMode();
    });

    exitBtnTop.addEventListener("click", () => {
      const ok = confirm("Spiel wirklich beenden?");
      if(ok){
        window.location.href = "about:blank";
      }
    });

    btnLevelTrainee.addEventListener("click", () => { if(busyMove) return; beginPlayerPhase(); });
    btnLevelBrainy.addEventListener("click", () => { if(busyMove) return; beginPlayerPhase(); });
    btnLevelBrain.addEventListener("click", () => { if(busyMove) return; beginPlayerPhase(); });

    if(btnKippBilanz){
      btnKippBilanz.addEventListener("click", () => {
        alert("KIPP Bilanz (noch ohne Funktion)");
      });
    }

    window.addEventListener("load", () => {
      setCellPx();
      requestAnimationFrame(setCellPx);
      setTimeout(setCellPx, 80);

      buildGridOnce();
      resetToW1Q0_Empty();
      showSpeedMode();
      setPoints(0);
    });

    window.addEventListener("resize", () => {
      setCellPx();
      requestAnimationFrame(setCellPx);
    });
  </script>
</body>
</html>
