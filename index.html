<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DigiKipp – Clean Grid</title>

  <style>
    :root{
      --violett: rgb(164, 27, 133);
      --blau:    rgb(0, 107, 179);
      --gruen:   rgb(0, 166, 82);
      --orange:  rgb(249, 150, 30);

      /* Grid-Grundwerte */
      --gap: 0px;
      --pad: 8px;

      /* dynamisch per JS gesetzt */
      --cell: 60px;
      --rowH: 60px;

      /* dein Hintergrundbild */
      --bg-img: url("Box_m_Hgr.png");
    }

    html, body { height: 100%; }
    body{
      margin:0;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      background: #111; /* neutraler Rand – kein Holz, kein Verlauf */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    /* ====== ROOT GRID (NEUER BEZUG FÜR ALLES) ======
       - 8 Spalten (A..H)
       - Header-Zeile (0.1/0.2) -> 1 Row
       - Dann Rows 1..20 -> 20 Rows
    */
    #uiGrid{
      width: min(96vw, 720px);
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: var(--rowH) repeat(20, var(--rowH));
      gap: var(--gap);
      position: relative;
      box-sizing: border-box;
      padding: 0; /* keine Alt-Panel-Ränder */
      background: transparent;
    }

    /* ====== HINTERGRUND (PNG) ======
       Deine PNG wird oben links bei 01A verankert
       -> Das entspricht hier: Start bei Row 1 (nach Header), Col A
       -> spannt über 8x8 (Rows 1..8, Cols A..H)
    */
    #bgBox{
      grid-column: 1 / span 8;
      grid-row: 2 / span 8; /* Row 1 entspricht grid-row:2 (weil header ist row:1) */
      position: relative;
      background-image: var(--bg-img);
      background-repeat: no-repeat;
      background-position: top left;
      background-size: 100% 100%;
      width: 100%;
      aspect-ratio: 1 / 1; /* 8x8 bleibt quadratisch */
      justify-self: stretch;
      align-self: start;
      overflow: visible;
    }

    /* ====== 8x8 LOGIK/OVERLAY GRID (transparent, ohne schwarze Flächen) ====== */
    #boardOverlay{
      position:absolute;
      inset:0;
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      gap: 0;
      pointer-events:none;
      z-index: 10;
    }
    .cell{
      background: transparent; /* KEIN schwarz */
      position: relative;
      box-sizing:border-box;
    }

    /* Farb-Zielfelder (nur wenn du sie sichtbar willst – sonst transparent lassen) */
    .cell.colorCell{ background: transparent; } /* PNG liefert Optik */
    /* Wenn du die Farbfelder als „unsichtbare Trefferzonen“ willst, bleibt das so. */

    /* ===== Target Zahl auf Zielfeldern ===== */
    @keyframes targetBreath{
      0%,100%{ transform: translate(-50%, -50%) rotate(var(--trot, 0deg)) scale(1); opacity: 0.95; }
      50%    { transform: translate(-50%, -50%) rotate(var(--trot, 0deg)) scale(1.10); opacity: 1; }
    }
    .targetBadge{
      position:absolute;
      left:50%;
      top:50%;
      font-weight: 900;
      font-size: clamp(18px, 8vmin, 36px);
      color: rgba(0,0,0,0.92);
      text-shadow: 0 1px 0 rgba(255,255,255,0.35);
      line-height: 1;
      pointer-events:none;
      z-index: 30;
      animation: targetBreath 1.25s ease-in-out infinite;
      transform-origin: 50% 50%;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .trot-top    { --trot: 0deg; }
    .trot-bottom { --trot: 180deg; }
    .trot-left   { --trot: -90deg; }
    .trot-right  { --trot: 90deg; }

    /* ===== HEADER (Zeile 0.1/0.2) ===== */
    #header{
      grid-column: 1 / span 8;
      grid-row: 1;
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      align-items:center;
      height: var(--rowH);
      position: relative;
      z-index: 50;
    }

    .navBtn{
      width: 46px;
      height: 46px;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;

      background: transparent;
      border: 2px solid rgba(255,255,255,0.9);
      box-shadow: none;
      padding:0;
    }
    .navBtn svg{
      width: 28px;
      height: 28px;
      stroke: rgba(255,255,255,0.92);
      stroke-width: 5;
      fill: none;
      stroke-linecap: square;
      stroke-linejoin: miter;
    }
    .navBtn:active{ transform: scale(0.98); }

    #backBtn{
      grid-column: 1 / span 2;
      justify-self:start;
      margin-left: var(--pad); /* 8px rein */
    }
    #exitBtnTop{
      grid-column: 7 / span 2;
      justify-self:end;
      margin-right: var(--pad); /* 8px rein */
    }

    #titleMain{
      grid-column: 3 / span 4;
      justify-self:center;
      text-align:center;
      color: #fff;
      font-weight: 1000;
      letter-spacing: 0.08em;
      font-size: clamp(22px, 6.0vmin, 44px);
      line-height: 1;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      text-shadow: 0 1px 0 rgba(0,0,0,0.4);
    }

    /* ===== UI BLOCK (ab Zeile 9/10) =====
       -> Row 9 entspricht grid-row: (header=1) + 9 => 10? Achtung:
       Wir haben:
         grid-row:1 = Header
         grid-row:2..9 = Rows 1..8 (Spielfeld)
         grid-row:10 = Row 9
       Also: Start bei grid-row:10
    */
    #uiBlock{
      grid-column: 1 / span 8;
      grid-row: 10 / span 4; /* Row 9..12 */
      display:flex;
      flex-direction: column;
      align-items: center;     /* alles mittig */
      justify-content: flex-start;
      gap: 14px;
      z-index: 60;
      color: #fff;
      text-align:center;
      padding-top: 8px;
    }

    /* ===== SPEED MODE ===== */
    .kippspeedLabel{
      font-weight: 1000;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      color: #fff;
      font-size: 16px;
      line-height: 1.05;
      user-select:none;
    }

    .squareBtn{
      width: 44px;
      height: 44px;
      border-radius: 0;
      border: 2px solid rgba(255,255,255,0.7);
      background: rgba(0,0,0,0.20);
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
    }
    .squareBtn:active{ transform: scale(0.985); }

    .playIcon{
      width: 0;
      height: 0;
      border-top: 11px solid transparent;
      border-bottom: 11px solid transparent;
      border-left: 18px solid rgba(255,255,255,0.92);
      transform: translateX(1px);
    }

    .pauseIcon{
      width: 18px;
      height: 22px;
      position: relative;
    }
    .pauseIcon::before,
    .pauseIcon::after{
      content:"";
      position:absolute;
      top:0;
      width: 6px;
      height: 22px;
      background: rgba(255,255,255,0.92);
    }
    .pauseIcon::before{ left: 0; }
    .pauseIcon::after { right: 0; }

    .okText{
      font-weight: 1000;
      letter-spacing: 0.06em;
      color: rgba(255,255,255,0.92);
      font-size: 16px;
      line-height: 1;
    }

    .sliderRow{
      display:flex;
      align-items:center;
      gap: 14px;
      justify-content:center;
      width: 100%;
    }

    .speedIcon{
      width: clamp(44px, 10vmin, 62px);
      height: clamp(44px, 10vmin, 62px);
      opacity: 0.98;
      filter: drop-shadow(0 1px 0 rgba(0,0,0,0.35));
    }

    input[type="range"]{
      -webkit-appearance: none;
      appearance: none;
      width: min(420px, 78vw);
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.16);
      outline: none;
      border: 1px solid rgba(255,255,255,0.35);
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance: none;
      appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 6px;
      background: rgba(255,255,255,0.85);
      border: 2px solid rgba(0,0,0,0.35);
      cursor: pointer;
    }

    .speedTop{
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 12px;
    }

    /* ===== GAME TEXT / BUTTONS (alles mittig) ===== */
    .gcBtn{
      border: 1px solid rgba(255,255,255,0.35);
      background: rgba(0,0,0,0.20);
      color: rgba(255,255,255,0.92);
      font-weight: 1000;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      padding: 12px 14px;
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      text-align:center;
      width: min(420px, 78vw);
    }
    .gcBtn:active{ transform: translateY(1px) scale(0.99); }

    .kippCountTitle{
      font-weight: 1000;
      letter-spacing: 0.10em;
      color: rgba(255,255,255,0.92);
      font-size: clamp(18px, 5.6vmin, 34px);
      line-height: 1.0;
      margin: 0;
      text-transform: none;
      text-align:center;
    }
    .kippStatus{
      font-weight: 1000;
      letter-spacing: 0.08em;
      color: rgba(255,255,255,0.92);
      font-size: clamp(12px, 3.9vmin, 16px);
      line-height: 1.05;
      margin: 0;
      text-transform: none;
      text-align:center;
    }

    .gcRow{
      display:flex;
      gap: 10px;
      justify-content:center;
      width: min(420px, 78vw);
    }

    .miniBtn{
      flex: 1 1 0;
      border: 1px solid rgba(255,255,255,0.35);
      background: rgba(0,0,0,0.20);
      color: rgba(255,255,255,0.92);
      font-weight: 1000;
      font-size: clamp(14px, 5.5vmin, 22px);
      line-height: 1;
      padding: 10px 0;
      cursor: pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      text-align:center;
    }
    .miniBtn:active{ transform: translateY(1px) scale(0.99); }
    .miniBtn.sel{ background: rgba(255,255,255,0.18); }

    .hidden{ display:none !important; }

    /* ===== SCORE (Zeile 13/14) =====
       Row 13 entspricht grid-row: (header=1) + 13 => 14
       wir setzen Scoreblock auf grid-row:14
    */
    #scoreRow{
      grid-column: 1 / span 8;
      grid-row: 14;
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 14px;
      z-index: 70;
      color: rgba(255,255,255,0.92);
      padding-top: 6px;
    }

    #btnKippBilanz{
      border: 1px solid rgba(255,255,255,0.35);
      background: rgba(0,0,0,0.20);
      color: rgba(255,255,255,0.92);
      font-weight: 1000;
      letter-spacing: 0.06em;
      padding: 12px 14px;
      cursor: pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      width: min(240px, 42vw);
      text-align:center;
    }
    #btnKippBilanz:active{ transform: translateY(1px) scale(0.99); }

    #gcPoints{
      font-weight: 1000;
      font-size: 34px;
      letter-spacing: 0.02em;
      white-space: nowrap;
    }

    /* ====== (WÜRFELOBJEKTE) ======
       Wir behalten deine Slots (Logik), aber ohne „Holzfläche“.
       Die Slots liegen über der PNG (bgBox).
    */
    .wFaceGroup,
    .kipGroup{
      position:absolute;
      inset:0;
      z-index: 40;
      pointer-events:none;

      --pivot-x: 50%;
      --pivot-y: 50%;
      transform-origin: 50% 50%;
      transform: rotate(var(--rot, 0deg));
    }

    .slot{
      position:absolute;
      width: 12.5%;
      height: 12.5%;
      box-sizing: border-box;
      background: rgba(255,255,255,0.72);
      border: 2px solid rgba(0,0,0,0.55);
      border-radius: 0;
      z-index: 45;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .slot .num > span{
      font-weight: 900;
      color: #111;
      font-size: clamp(18px, 8vmin, 36px);
      text-shadow: 0 1px 0 rgba(255,255,255,0.35);
      transform: rotate(var(--num-rot, 0deg));
      transform-origin: 50% 50%;
      line-height: 1;
    }

    /* Lesbarkeit (wie bei dir) */
    .read-south { --num-rot: 0deg; }
    .read-west  { --num-rot: 90deg; }
    .read-east  { --num-rot: -90deg; }
    .read-north { --num-rot: 180deg; }

    /* Positionen (als Prozent im 8x8) – entspricht deinen Slots:
       BASE_SLOT_COORDS = 3B,4B,2C,2D (im INNER 6x6 Bereich).
       Wir legen sie hier direkt „optisch“ passend (du kannst später feinjustieren).
    */
    .s-3b{ left: 12.5%; top: 25%; }
    .s-4b{ left: 12.5%; top: 37.5%; }
    .s-2c{ left: 25%;   top: 12.5%; }
    .s-2d{ left: 37.5%; top: 12.5%; }

    /* KIP Preview (zwei Hälften) – ebenfalls grob, feinjustieren später */
    .kipScale{
      position:absolute;
      inset:0;
      transform: scaleX(0.6666667);
      transform-origin: 50% 50%;
    }
    .kipFaceQ0{ left: 12.5%; top: 12.5%; }
    .kipFaceQ1{ left: 50%;   top: 12.5%; }

    .k-4d{ left: 37.5%; top: 37.5%; }
    .k-3d{ left: 37.5%; top: 25%; }
    .k-2b{ left: 12.5%; top: 12.5%; }
    .k-2c{ left: 25%;   top: 12.5%; }

    .k-3e{ left: 50%;   top: 25%; }
    .k-4e{ left: 50%;   top: 37.5%; }
    .k-2f{ left: 62.5%; top: 12.5%; }
    .k-2g{ left: 75%;   top: 12.5%; }

  </style>
</head>

<body>

  <div id="uiGrid">

    <!-- HEADER: Zeile 0.1/0.2 -->
    <div id="header" aria-label="Header">
      <button id="backBtn" class="navBtn" aria-label="Zurück" type="button">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M15 5L8 12l7 7"></path>
        </svg>
      </button>

      <div id="titleMain">KIPP COLOR</div>

      <button id="exitBtnTop" class="navBtn" aria-label="Schließen" type="button">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M6 6l12 12M18 6L6 18"></path>
        </svg>
      </button>
    </div>

    <!-- SPIELFLÄCHE 8x8 (Rows 1..8) mit PNG -->
    <div id="bgBox" aria-label="Box Hintergrund">
      <div id="boardOverlay" aria-label="8×8 Raster"></div>

      <div id="wFaceGroup" class="wFaceGroup" aria-label="W Paket">
        <div class="slot s-3b read-west"  data-slot="S1"><div class="num"><span></span></div></div>
        <div class="slot s-4b read-west"  data-slot="S2"><div class="num"><span></span></div></div>
        <div class="slot s-2c read-north" data-slot="S3"><div class="num"><span></span></div></div>
        <div class="slot s-2d read-north" data-slot="S4"><div class="num"><span></span></div></div>
      </div>

      <div id="kipGroup" class="kipGroup hidden" aria-label="KIP Gruppe">
        <div class="kipScale">
          <div class="slot k-4d read-east"  data-slot="W2_A"><div class="num"><span></span></div></div>
          <div class="slot k-3d read-east"  data-slot="W2_B"><div class="num"><span></span></div></div>
          <div class="slot k-2b read-north" data-slot="W2_C"><div class="num"><span></span></div></div>
          <div class="slot k-2c read-north" data-slot="W2_D"><div class="num"><span></span></div></div>

          <div class="slot k-3e read-west"  data-slot="W1_1"><div class="num"><span></span></div></div>
          <div class="slot k-4e read-west"  data-slot="W1_2"><div class="num"><span></span></div></div>
          <div class="slot k-2f read-north" data-slot="W1_3"><div class="num"><span></span></div></div>
          <div class="slot k-2g read-north" data-slot="W1_4"><div class="num"><span></span></div></div>
        </div>
      </div>
    </div>

    <!-- UI ab Zeile 9/10 (alles mittig) -->
    <div id="uiBlock" aria-label="UI Block">

      <!-- SPEED MODE -->
      <div id="speedMode">
        <div class="speedTop">
          <div class="kippspeedLabel" id="kippspeedLabel">KIPP SPEED (KSP)</div>

          <button id="btnPlay" class="squareBtn" aria-label="Demo starten/pausieren" type="button">
            <span id="playGlyph" class="playIcon" aria-hidden="true"></span>
          </button>

          <button id="btnOk" class="squareBtn" aria-label="OK" type="button">
            <span class="okText">OK</span>
          </button>
        </div>

        <div class="sliderRow">
          <img class="speedIcon" src="kippspeed_snail_tight.png" alt="langsam">
          <input id="speedSlider" type="range" min="0" max="9" value="3" step="1" aria-label="Speed Slider">
          <img class="speedIcon" src="kippspeed_hase_tight.png" alt="schnell">
        </div>
      </div>

      <!-- GAME MODE -->
      <div id="gameMode" class="hidden" aria-label="Game Mode">
        <div id="previewHint" class="kippStatus">SCHAU GENAU!</div>
        <button id="btnSetNumbers" class="gcBtn" type="button">VORSCHAU-KIPPS</button>

        <div id="levelPanel" class="hidden" aria-label="Level wählen">
          <div class="kippCountTitle" id="levelTitle">LEVEL WÄHLEN</div>
          <div class="gcRow">
            <button id="btnLevelTrainee" class="miniBtn" type="button">Trainee</button>
            <button id="btnLevelBrainy"  class="miniBtn" type="button">Brainy</button>
            <button id="btnLevelBrain"   class="miniBtn" type="button">Brain</button>
          </div>
        </div>

        <div id="decisionPanel" class="hidden" aria-label="Decision Panel">
          <div class="kippCountTitle" id="kippTitle">KIPP Anzahl wählen</div>
          <div class="kippStatus" id="kippStatus">Tippe auf eine Taste</div>

          <div class="gcRow" aria-label="Kippanzahl">
            <button class="miniBtn" data-k="3" type="button">3</button>
            <button class="miniBtn" data-k="6" type="button">6</button>
            <button class="miniBtn" data-k="9" type="button">9</button>
          </div>
        </div>
      </div>

    </div>

    <!-- Score Zeile 13/14 -->
    <div id="scoreRow" aria-label="Score Row">
      <button id="btnKippBilanz" type="button">KIPP Bilanz</button>
      <div id="gcPoints">P00/80</div>
    </div>

  </div>

  <script>
    /* ========= ELEMENTE ========= */
    const bgBox      = document.getElementById("bgBox");
    const grid       = document.getElementById("boardOverlay");

    const wFace      = document.getElementById("wFaceGroup");
    const kipGroup   = document.getElementById("kipGroup");

    const speedSlider = document.getElementById("speedSlider");

    const speedMode   = document.getElementById("speedMode");
    const gameMode    = document.getElementById("gameMode");

    const btnPlay     = document.getElementById("btnPlay");
    const playGlyph   = document.getElementById("playGlyph");
    const btnOk       = document.getElementById("btnOk");

    const backBtn     = document.getElementById("backBtn");
    const exitBtnTop  = document.getElementById("exitBtnTop");

    const btnSetNumbers = document.getElementById("btnSetNumbers");
    const decisionPanel = document.getElementById("decisionPanel");

    const gcPoints    = document.getElementById("gcPoints");

    const levelPanel = document.getElementById("levelPanel");
    const levelTitle = document.getElementById("levelTitle");
    const btnLevelTrainee = document.getElementById("btnLevelTrainee");
    const btnLevelBrainy  = document.getElementById("btnLevelBrainy");
    const btnLevelBrain   = document.getElementById("btnLevelBrain");

    const previewHintEl = document.getElementById("previewHint");
    const kippTitleEl  = document.getElementById("kippTitle");
    const kippStatusEl = document.getElementById("kippStatus");

    function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

    /* ========= GRID / SIZE ========= */
    function setCellFromBox(){
      const w = Math.round(bgBox.getBoundingClientRect().width);
      const cell = Math.max(32, Math.round(w / 8));
      document.documentElement.style.setProperty("--cell", cell + "px");
      document.documentElement.style.setProperty("--rowH", cell + "px");
    }

    /* ========= 8x8 Raster Logik ========= */
    const cols = ["A","B","C","D","E","F","G","H"];
    function key(r, cLetter){ return `${r}${cLetter}`; }

    const colorMap = new Map([
      [key(3,"A"), "c-orange"],
      [key(4,"A"), "c-gruen"],
      [key(5,"A"), "c-violett"],
      [key(6,"A"), "c-blau"],

      [key(8,"C"), "c-gruen"],
      [key(8,"D"), "c-orange"],
      [key(8,"E"), "c-gruen"],
      [key(8,"F"), "c-orange"],

      [key(6,"H"), "c-violett"],
      [key(5,"H"), "c-blau"],
      [key(4,"H"), "c-orange"],
      [key(3,"H"), "c-gruen"],

      [key(1,"F"), "c-blau"],
      [key(1,"E"), "c-violett"],
      [key(1,"D"), "c-blau"],
      [key(1,"C"), "c-violett"],
    ]);

    function buildGridOnce(){
      if (grid.dataset.built === "1") return;
      for(let r=1; r<=8; r++){
        for(let c=0; c<8; c++){
          const cell = document.createElement("div");
          cell.className = "cell";
          const coord = key(r, cols[c]);
          cell.dataset.coord = coord;
          if(colorMap.has(coord)){
            cell.classList.add("colorCell");
            cell.classList.add(colorMap.get(coord));
          }
          grid.appendChild(cell);
        }
      }
      grid.dataset.built = "1";
    }

    function clearTargets(){
      Array.from(grid.querySelectorAll(".targetBadge")).forEach(el => el.remove());
    }

    function sideClassForCoord(coord){
      const r = parseInt(coord, 10);
      const c = coord.replace(String(r), "");
      if(r === 1) return "trot-top";
      if(r === 8) return "trot-bottom";
      if(c === "A") return "trot-left";
      if(c === "H") return "trot-right";
      return "trot-bottom";
    }

    function showTargetOnAllSameColor(colorClass, n){
      clearTargets();
      Array.from(grid.children).forEach(cell=>{
        if(!cell.classList.contains("colorCell")) return;
        if(!cell.classList.contains(colorClass)) return;

        const coord = cell.dataset.coord;
        const badge = document.createElement("div");
        badge.className = "targetBadge " + sideClassForCoord(coord);
        badge.textContent = String(n);
        cell.appendChild(badge);
      });
    }

    /* ========= W/KIP Anzeige ========= */
    function renderNumber(span, n){
      if(!span) return;
      span.textContent = (n === null || n === undefined) ? "" : String(n);
    }

    function getUniqueRandomNumbers(count, min, max){
      const pool = [];
      for(let i=min; i<=max; i++) pool.push(i);
      for(let i=pool.length-1; i>0; i--){
        const j = Math.floor(Math.random() * (i+1));
        [pool[i], pool[j]] = [pool[j], pool[i]];
      }
      return pool.slice(0, count);
    }

    const rotDeg = [0, 90, 180, 270];
    let rotIndex  = 0;
    let faceIndex = 0;

    function setRotationSnap(){
      const deg = rotDeg[rotIndex];
      wFace.style.setProperty("--rot", deg + "deg");
      kipGroup.style.setProperty("--rot", deg + "deg");
    }

    function advanceFullCW(){
      rotIndex  = (rotIndex + 1) % 4;
      faceIndex = (faceIndex + 1) % 3;
      setRotationSnap();
    }

    const slotTargetsW = [
      wFace.querySelector('[data-slot="S1"] .num > span'),
      wFace.querySelector('[data-slot="S2"] .num > span'),
      wFace.querySelector('[data-slot="S3"] .num > span'),
      wFace.querySelector('[data-slot="S4"] .num > span'),
    ];

    const slotTargetsKipRight = [
      kipGroup.querySelector('[data-slot="W1_1"] .num > span'),
      kipGroup.querySelector('[data-slot="W1_2"] .num > span'),
      kipGroup.querySelector('[data-slot="W1_3"] .num > span'),
      kipGroup.querySelector('[data-slot="W1_4"] .num > span'),
    ];

    const slotTargetsKipLeft = [
      kipGroup.querySelector('[data-slot="W2_A"] .num > span'),
      kipGroup.querySelector('[data-slot="W2_B"] .num > span'),
      kipGroup.querySelector('[data-slot="W2_C"] .num > span'),
      kipGroup.querySelector('[data-slot="W2_D"] .num > span'),
    ];

    function clearAllNumbers(){
      [...slotTargetsW, ...slotTargetsKipRight, ...slotTargetsKipLeft].forEach(s => { if(s) s.textContent = ""; });
    }

    function showW(){
      kipGroup.classList.add("hidden");
      wFace.classList.remove("hidden");
    }
    function showKip(){
      wFace.classList.add("hidden");
      kipGroup.classList.remove("hidden");
    }

    function renderWEmpty(){
      setRotationSnap();
      for(let i=0;i<4;i++) renderNumber(slotTargetsW[i], null);
    }

    function renderKipEmpty(){
      setRotationSnap();
      for(let i=0;i<4;i++){
        renderNumber(slotTargetsKipRight[i], null);
        renderNumber(slotTargetsKipLeft[i], null);
      }
    }

    function resetToW1Q0_Empty(){
      rotIndex = 0;
      faceIndex = 0;
      setRotationSnap();
      clearAllNumbers();
      showW();
      renderWEmpty();
    }

    function getTiming(){
      const v = Number(speedSlider.value || 3);
      const hold = Math.max(520, Math.round(2200 - v * 186));
      const kip = Math.max(160, Math.round(hold * 0.50));
      const wfull = hold;
      return { holdMs: hold, kipMs: kip, wMs: wfull };
    }

    function setPlayGlyph(isPause){
      playGlyph.className = isPause ? "pauseIcon" : "playIcon";
    }

    function showSpeedMode(){
      speedMode.classList.remove("hidden");
      gameMode.classList.add("hidden");
      if(previewHintEl) previewHintEl.classList.remove("hidden");
      setPlayGlyph(false);
    }

    function showGameMode(){
      speedMode.classList.add("hidden");
      gameMode.classList.remove("hidden");

      btnSetNumbers.classList.remove("hidden");
      decisionPanel.classList.add("hidden");
      levelPanel.classList.add("hidden");

      if(previewHintEl) previewHintEl.classList.remove("hidden");

      setPoints(0);
    }

    /* ========= DEMO ========= */
    let hasAdjustedOnce = false;
    let runningDemo     = false;
    let demoPaused      = false;
    let demoToken       = 0;

    async function waitOrPause(ms, myToken){
      const slice = 40;
      let elapsed = 0;
      while(elapsed < ms){
        if(myToken !== demoToken) return false;
        if(demoPaused){
          await sleep(60);
          continue;
        }
        const step = Math.min(slice, ms - elapsed);
        await sleep(step);
        elapsed += step;
      }
      return (myToken === demoToken);
    }

    async function runDemoCycle(){
      if(runningDemo) return;
      runningDemo = true;
      demoPaused = false;
      const myToken = ++demoToken;

      const T = getTiming();

      showKip(); renderKipEmpty();
      if(!await waitOrPause(T.kipMs, myToken)) { runningDemo=false; return; }

      advanceFullCW(); showW(); renderWEmpty();
      if(!await waitOrPause(T.wMs, myToken)) { runningDemo=false; return; }

      showKip(); renderKipEmpty();
      if(!await waitOrPause(T.kipMs, myToken)) { runningDemo=false; return; }

      advanceFullCW(); showW(); renderWEmpty();
      if(!await waitOrPause(T.wMs, myToken)) { runningDemo=false; return; }

      showKip(); renderKipEmpty();
      if(!await waitOrPause(T.kipMs, myToken)) { runningDemo=false; return; }

      advanceFullCW(); showW(); renderWEmpty();
      if(!await waitOrPause(T.wMs, myToken)) { runningDemo=false; return; }

      showKip(); renderKipEmpty();
      if(!await waitOrPause(T.kipMs, myToken)) { runningDemo=false; return; }

      advanceFullCW(); showW(); renderWEmpty();
      if(!await waitOrPause(T.wMs, myToken)) { runningDemo=false; return; }

      runningDemo = false;
    }

    function cancelDemo(){
      demoToken++;
      runningDemo = false;
      demoPaused = false;
      setPlayGlyph(false);
    }

    /* ========= SET NUMBERS / SPIEL ========= */
    let planned = [
      [null,null,null,null],
      [null,null,null,null],
      [null,null,null,null],
    ];
    let sets = [
      [null,null,null,null],
      [null,null,null,null],
      [null,null,null,null],
    ];
    let assigned = [false,false,false];

    function ensureAssigned(idx){
      if(assigned[idx]) return;
      sets[idx] = planned[idx].slice();
      assigned[idx] = true;
    }

    function renderW(){
      setRotationSnap();
      const curr = sets[faceIndex];
      for(let i=0;i<4;i++) renderNumber(slotTargetsW[i], curr[i]);
    }

    function mapHiddenToVisible_CW(face){
      const [f1,f2,f3,f4] = face;
      return [f4, f3, f2, f1];
    }

    function renderKip(){
      setRotationSnap();
      const curr = sets[faceIndex];
      const nextFaceIndex = (faceIndex + 1) % 3;
      const next = sets[nextFaceIndex];

      for(let i=0;i<4;i++) renderNumber(slotTargetsKipRight[i], curr[i]);
      const nextPreview = mapHiddenToVisible_CW(next);
      for(let i=0;i<4;i++) renderNumber(slotTargetsKipLeft[i], nextPreview[i]);
    }

    function reroll12_keepEmpty(){
      const twelve = getUniqueRandomNumbers(12, 1, 12);
      planned[0] = twelve.slice(0,4);
      planned[1] = twelve.slice(4,8);
      planned[2] = twelve.slice(8,12);

      sets = [
        [null,null,null,null],
        [null,null,null,null],
        [null,null,null,null],
      ];
      assigned = [false,false,false];

      rotIndex  = 0;
      faceIndex = 0;

      clearAllNumbers();
      setRotationSnap();
    }

    let runningSet = false;
    let setToken = 0;

    async function runSetNumbersCycle(){
      if(runningSet) return;
      runningSet = true;
      const myToken = ++setToken;

      reroll12_keepEmpty();

      const T = getTiming();

      showW(); renderWEmpty();
      await sleep(T.wMs);
      if(myToken!==setToken){ runningSet=false; return; }

      ensureAssigned(0); renderW();
      await sleep(T.wMs);
      if(myToken!==setToken){ runningSet=false; return; }

      showKip(); renderKip();
      await sleep(T.kipMs);
      if(myToken!==setToken){ runningSet=false; return; }

      advanceFullCW(); showW(); renderWEmpty();
      await sleep(T.wMs);
      if(myToken!==setToken){ runningSet=false; return; }

      ensureAssigned(1); renderW();
      await sleep(T.wMs);
      if(myToken!==setToken){ runningSet=false; return; }

      showKip(); renderKip();
      await sleep(T.kipMs);
      if(myToken!==setToken){ runningSet=false; return; }

      advanceFullCW(); showW(); renderWEmpty();
      await sleep(T.wMs);
      if(myToken!==setToken){ runningSet=false; return; }

      ensureAssigned(2); renderW();
      await sleep(T.wMs);
      if(myToken!==setToken){ runningSet=false; return; }

      showKip(); renderKip();
      await sleep(T.kipMs);
      if(myToken!==setToken){ runningSet=false; return; }

      advanceFullCW();
      showW();
      renderW();

      runningSet = false;

      // Level Auswahl zeigen
      btnSetNumbers.classList.add("hidden");
      decisionPanel.classList.add("hidden");
      levelPanel.classList.remove("hidden");
      if(previewHintEl) previewHintEl.classList.add("hidden");
      levelTitle.textContent = "LEVEL WÄHLEN";
    }

    function cancelSetNumbers(){
      setToken++;
      runningSet = false;
    }

    /* ========= SPIELREGELN (gleich wie vorher) ========= */
    const MAX_ROUNDS = 10;
    const MAX_TRIES  = 3;
    const SCORE_BY_TRY = [8,5,3];

    let roundIndex = 0;
    let tryIndex   = 0;
    let points     = 0;

    let currentTargetColor = null;
    let currentTargetNumber = null;

    function setPoints(p){
      points = Math.max(0, p|0);
      const s = String(points).padStart(2, "0");
      gcPoints.textContent = "P" + s + "/80";
    }

    const colToX = {A:1,B:2,C:3,D:4,E:5,F:6,G:7,H:8};
    const xToCol = ["","A","B","C","D","E","F","G","H"];

    function parseCoord(coord){
      const r = parseInt(coord, 10);
      const c = coord.replace(String(r), "");
      return { x: colToX[c], y: r };
    }
    function makeCoord(x,y){
      return `${y}${xToCol[x]}`;
    }
    function rotateCoordCW(coord, times){
      let {x,y} = parseCoord(coord);
      let t = ((times%4)+4)%4;
      for(let i=0;i<t;i++){
        const nx = y;
        const ny = 9 - x;
        x = nx; y = ny;
      }
      return makeCoord(x,y);
    }

    const BASE_SLOT_COORDS = ["3B","4B","2C","2D"];

    function currentInnerMap(){
      const curr = sets[faceIndex] || [];
      const map = new Map();
      for(let i=0;i<4;i++){
        const base = BASE_SLOT_COORDS[i];
        const abs  = rotateCoordCW(base, rotIndex);
        const n    = curr[i];
        if(n != null) map.set(abs, n);
      }
      return map;
    }

    const TARGET_COORDS = [
      "3A","4A","5A","6A",
      "3H","4H","5H","6H",
      "1C","1D","1E","1F",
      "8C","8D","8E","8F",
    ];

    function adjacentInnerCoordForTarget(targetCoord){
      const {x,y} = parseCoord(targetCoord);
      if(x === 1) return makeCoord(2, y);
      if(x === 8) return makeCoord(7, y);
      if(y === 1) return makeCoord(x, 2);
      if(y === 8) return makeCoord(x, 7);
      return null;
    }

    function getCubeQuadrant(){
      return rotIndex;
    }

    function quadrantOfCoord(coord){
      const {x,y} = parseCoord(coord);
      const left  = (x <= 4);
      const top   = (y <= 4);
      if(top && left) return 0;
      if(top && !left) return 1;
      if(!top && !left) return 2;
      return 3;
    }

    const QUAD_FIELD_COORDS = {
      0: {1:"4A", 2:"3A", 3:"1C", 4:"1D"},
      1: {1:"1E", 2:"1F", 3:"3H", 4:"4H"},
      2: {1:"5H", 2:"6H", 3:"8F", 4:"8E"},
      3: {1:"8D", 2:"8C", 3:"6A", 4:"5A"},
    };

    function fieldIdForTargetCoord(coord, quad){
      const q = QUAD_FIELD_COORDS[quad];
      if(!q) return null;
      for(const fid of [1,2,3,4]){
        if(q[fid] === coord) return fid;
      }
      return null;
    }

    function slotIdAtInnerCoord(innerCoord){
      for(let i=0;i<4;i++){
        const abs = rotateCoordCW(BASE_SLOT_COORDS[i], rotIndex);
        if(abs === innerCoord) return (i+1);
      }
      return null;
    }

    function colorRgbForClass(colorClass){
      const root = getComputedStyle(document.documentElement);
      if(colorClass === "c-orange")  return root.getPropertyValue("--orange").trim();
      if(colorClass === "c-gruen")   return root.getPropertyValue("--gruen").trim();
      if(colorClass === "c-violett") return root.getPropertyValue("--violett").trim();
      if(colorClass === "c-blau")    return root.getPropertyValue("--blau").trim();
      return "#fff";
    }

    function ordinalDeTitle(k){
      const map = ["Erstes","Zweites","Drittes","Viertes","Fünftes","Sechstes","Siebentes","Achtes","Neuntes","Zehntes"];
      if(k >= 1 && k <= 10) return map[k-1];
      return "Nächstes";
    }

    function setGoalInfoText(roundOneBased){
      const ord = ordinalDeTitle(roundOneBased);
      const rgb = colorRgbForClass(currentTargetColor);
      kippTitleEl.innerHTML = `${ord} <span style="color:${rgb}; font-weight:1000;">KIPP-ZIEL</span> (von zehn)`;
      kippStatusEl.textContent = "Wähle deine KIPP Anzahl";
    }

    function setTryText(){
      if(tryIndex === 0){
        kippTitleEl.textContent  = "KIPP Anzahl wählen";
        kippStatusEl.textContent = "Tippe auf eine Taste";
      }else if(tryIndex === 1){
        kippTitleEl.textContent  = "ZWEITER VERSUCH";
        kippStatusEl.textContent = "KIPPANZAHL WÄHLEN";
      }else{
        kippTitleEl.textContent  = "LETZTER VERSUCH";
        kippStatusEl.textContent = "KIPPANZAHL WÄHLEN";
      }
    }

    function isHitForTarget(inner, targetColor, targetNumber){
      const quad = getCubeQuadrant();

      const candidates = TARGET_COORDS
        .filter(tc => colorMap.get(tc) === targetColor)
        .filter(tc => quadrantOfCoord(tc) === quad);

      for(const tc of candidates){
        const fid = fieldIdForTargetCoord(tc, quad);
        if(fid == null) continue;

        const adj = adjacentInnerCoordForTarget(tc);
        if(!adj) continue;

        const sid = slotIdAtInnerCoord(adj);
        if(sid == null) continue;

        if(sid !== fid) continue;

        if(inner.get(adj) === targetNumber) return true;
      }
      return false;
    }

    function pickNewTarget(){
      const inner = currentInnerMap();
      const visibleNums = Array.from(new Set(Array.from(inner.values())));

      if(visibleNums.length === 0){
        currentTargetColor = "c-orange";
        currentTargetNumber = 1;
        showTargetOnAllSameColor(currentTargetColor, currentTargetNumber);
        return;
      }

      const allColors = Array.from(new Set(TARGET_COORDS.map(tc=>colorMap.get(tc)).filter(Boolean)));

      let guard = 0;
      while(guard < 200){
        const col = allColors[Math.floor(Math.random()*allColors.length)] || "c-orange";
        const n   = visibleNums[Math.floor(Math.random()*visibleNums.length)];
        const hitNow = isHitForTarget(inner, col, n);
        if(!hitNow){
          currentTargetColor = col;
          currentTargetNumber = n;
          showTargetOnAllSameColor(currentTargetColor, currentTargetNumber);
          return;
        }
        guard++;
      }

      currentTargetColor = allColors[Math.floor(Math.random()*allColors.length)] || "c-orange";
      currentTargetNumber = visibleNums[Math.floor(Math.random()*visibleNums.length)];
      showTargetOnAllSameColor(currentTargetColor, currentTargetNumber);
    }

    function evaluateHit(){
      if(!currentTargetColor || currentTargetNumber == null) return false;
      const inner = currentInnerMap();
      return isHitForTarget(inner, currentTargetColor, currentTargetNumber);
    }

    let selectedKippCount = null;
    let busyMove = false;

    function setButtonsEnabled(enabled){
      document.querySelectorAll('.miniBtn[data-k]').forEach(btn=>{
        btn.disabled = !enabled;
      });
    }

    function selectKippCount(k){
      selectedKippCount = (k == null) ? null : Number(k);
      document.querySelectorAll('.miniBtn[data-k]').forEach(btn=>{
        btn.classList.toggle("sel", Number(btn.dataset.k) === selectedKippCount);
      });
    }

    async function performKippCW(count){
      if(busyMove) return;
      if(!count) return;

      busyMove = true;
      setButtonsEnabled(false);

      const c = Math.max(1, Math.min(9, Number(count)));
      const T = getTiming();

      for(let i=0; i<c; i++){
        showKip();
        renderKip();
        await sleep(T.kipMs);

        advanceFullCW();

        showW();
        renderW();
        await sleep(T.wMs);
      }

      const hit = evaluateHit();

      if(hit){
        const add = SCORE_BY_TRY[Math.min(tryIndex, SCORE_BY_TRY.length-1)] || 0;
        setPoints(points + add);

        roundIndex++;
        tryIndex = 0;

        if(roundIndex >= MAX_ROUNDS){
          clearTargets();
          alert("ENDE! Punkte: " + points);
          showSpeedMode();
          busyMove = false;
          setButtonsEnabled(true);
          return;
        }

        pickNewTarget();
        setGoalInfoText(roundIndex + 1);

      }else{
        tryIndex++;

        if(tryIndex >= MAX_TRIES){
          roundIndex++;
          tryIndex = 0;

          if(roundIndex >= MAX_ROUNDS){
            clearTargets();
            alert("ENDE! Punkte: " + points);
            showSpeedMode();
            busyMove = false;
            setButtonsEnabled(true);
            return;
          }

          pickNewTarget();
          setGoalInfoText(roundIndex + 1);
        }
      }

      selectKippCount(null);
      setTryText();
      setButtonsEnabled(true);

      busyMove = false;
    }

    document.querySelectorAll('.miniBtn[data-k]').forEach(btn=>{
      btn.addEventListener("click", () => {
        if(busyMove) return;
        selectKippCount(btn.dataset.k);
        performKippCW(selectedKippCount);
      });
    });

    function beginPlayerPhase(){
      levelPanel.classList.add("hidden");
      btnSetNumbers.classList.add("hidden");
      decisionPanel.classList.remove("hidden");

      roundIndex = 0;
      tryIndex = 0;
      setPoints(points);

      pickNewTarget();
      setGoalInfoText(1);
      setTryText();

      selectKippCount(null);
      setButtonsEnabled(true);
    }

    /* ========= EVENTS ========= */
    speedSlider.addEventListener("input", () => {
      hasAdjustedOnce = true;
    });

    btnPlay.addEventListener("click", async () => {
      if(!hasAdjustedOnce) {}
      if(!runningDemo){
        setPlayGlyph(true);
        await runDemoCycle();
        setPlayGlyph(false);
        return;
      }
      demoPaused = !demoPaused;
      setPlayGlyph(demoPaused ? false : true);
    });

    btnOk.addEventListener("click", () => {
      cancelDemo();
      cancelSetNumbers();
      resetToW1Q0_Empty();
      showGameMode();
    });

    btnSetNumbers.addEventListener("click", async () => {
      if(previewHintEl) previewHintEl.classList.remove("hidden");
      await runSetNumbersCycle();
    });

    backBtn.addEventListener("click", () => {
      cancelDemo();
      cancelSetNumbers();
      busyMove = false;
      clearTargets();

      levelPanel.classList.add("hidden");
      decisionPanel.classList.add("hidden");

      resetToW1Q0_Empty();
      showSpeedMode();
    });

    exitBtnTop.addEventListener("click", () => {
      const ok = confirm("Spiel wirklich beenden?");
      if(ok){
        window.location.href = "about:blank";
      }
    });

    btnLevelTrainee.addEventListener("click", () => { if(busyMove) return; beginPlayerPhase(); });
    btnLevelBrainy.addEventListener("click", () => { if(busyMove) return; beginPlayerPhase(); });
    btnLevelBrain.addEventListener("click", () => { if(busyMove) return; beginPlayerPhase(); });

    document.getElementById("btnKippBilanz").addEventListener("click", () => {
      alert("KIPP Bilanz (noch ohne Funktion)");
    });

    window.addEventListener("load", () => {
      setCellFromBox();
      buildGridOnce();
      resetToW1Q0_Empty();
      showSpeedMode();
      setPoints(0);
    });

    window.addEventListener("resize", () => {
      setCellFromBox();
    });
  </script>
</body>
</html>
